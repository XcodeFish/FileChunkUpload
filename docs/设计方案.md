# å¤§æ–‡ä»¶ä¸Šä¼ npmä¾èµ–åŒ…æ¶æ„è®¾è®¡æ–¹æ¡ˆï¼ˆä¼˜åŒ–ç‰ˆï¼‰

## é¡¹ç›®æ¦‚è¿°

åç§°ï¼šfile-chunk-uploader
å®šä½ï¼šä¸€ä¸ªè½»é‡çº§ã€é«˜æ€§èƒ½ã€æ˜“ç”¨çš„å¤§æ–‡ä»¶ä¸Šä¼ è§£å†³æ–¹æ¡ˆï¼Œæ”¯æŒå¤šæ¡†æ¶ç¯å¢ƒ

## æ ¸å¿ƒæ¶æ„è®¾è®¡

### 1. æ¨¡å—åŒ–è®¾è®¡

é‡‡ç”¨æ’ä»¶åŒ–å¾®åŒ…æ¶æ„è¿›è¡Œç²¾ç»†åŒ–çš„åŒ…ç®¡ç†ï¼š

```text
file-chunk-uploader/
â”œâ”€â”€ packages/
â”‚   â”œâ”€â”€ core/                    # ä¸Šä¼ å™¨æ ¸å¿ƒï¼ˆæœ€å°å®ç°ï¼‰
â”‚   â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”‚   â”œâ”€â”€ uploader.ts      # ä¸Šä¼ å™¨åŸºç¡€ç±»
â”‚   â”‚   â”‚   â”œâ”€â”€ plugin-manager.ts # æ’ä»¶ç®¡ç†å™¨
â”‚   â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ chunk/                   # æ–‡ä»¶åˆ†ç‰‡åŠŸèƒ½åŒ…
â”‚   â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”‚   â”œâ”€â”€ file-handler.ts  # æ–‡ä»¶å¤„ç†ä¸åˆ‡ç‰‡
â”‚   â”‚   â”‚   â”œâ”€â”€ chunk-strategy.ts # åˆ†ç‰‡ä¸Šä¼ ç­–ç•¥
â”‚   â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ resume/                  # æ–­ç‚¹ç»­ä¼ åŠŸèƒ½åŒ…
â”‚   â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”‚   â”œâ”€â”€ resume-strategy.ts # æ–­ç‚¹ç»­ä¼ ç­–ç•¥
â”‚   â”‚   â”‚   â”œâ”€â”€ storage.ts       # ä¸Šä¼ è¿›åº¦å­˜å‚¨
â”‚   â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ fast/                    # ç§’ä¼ åŠŸèƒ½åŒ…
â”‚   â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”‚   â”œâ”€â”€ fast-strategy.ts # ç§’ä¼ ç­–ç•¥
â”‚   â”‚   â”‚   â”œâ”€â”€ hash.ts          # æ–‡ä»¶å“ˆå¸Œè®¡ç®—
â”‚   â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ network/                 # ç½‘ç»œè¯·æ±‚åŠŸèƒ½åŒ…
â”‚   â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”‚   â”œâ”€â”€ adapters/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ xhr-adapter.ts   # XHRé€‚é…å™¨
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ fetch-adapter.ts # Fetché€‚é…å™¨
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ detector.ts         # ç½‘ç»œæ£€æµ‹
â”‚   â”‚   â”‚   â”œâ”€â”€ adaptive.ts         # è‡ªé€‚åº”ç­–ç•¥
â”‚   â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ security/                # å®‰å…¨åŠŸèƒ½åŒ…
â”‚   â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”‚   â”œâ”€â”€ validator.ts      # æ–‡ä»¶éªŒè¯
â”‚   â”‚   â”‚   â”œâ”€â”€ encryption.ts     # åŠ å¯†å¤„ç†
â”‚   â”‚   â”‚   â”œâ”€â”€ content-scanner.ts # æ–‡ä»¶å†…å®¹æ‰«æ
â”‚   â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ utils/                   # é€šç”¨å·¥å…·åŒ…
â”‚   â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”‚   â”œâ”€â”€ throttle.ts       # èŠ‚æµæ§åˆ¶
â”‚   â”‚   â”‚   â”œâ”€â”€ logger.ts         # æ—¥å¿—å·¥å…·
â”‚   â”‚   â”‚   â”œâ”€â”€ observable.ts     # Observableæ”¯æŒ
â”‚   â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ errors/                  # é”™è¯¯å¤„ç†åŒ…
â”‚   â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”‚   â”œâ”€â”€ error-types.ts    # é”™è¯¯ç±»å‹å®šä¹‰
â”‚   â”‚   â”‚   â”œâ”€â”€ error-handler.ts  # é”™è¯¯å¤„ç†å™¨
â”‚   â”‚   â”‚   â”œâ”€â”€ recovery.ts       # é”™è¯¯æ¢å¤æœºåˆ¶
â”‚   â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ monitoring/              # ç›‘æ§ä¸åˆ†æåŒ…
â”‚   â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”‚   â”œâ”€â”€ metrics.ts        # æ€§èƒ½æŒ‡æ ‡æ”¶é›†
â”‚   â”‚   â”‚   â”œâ”€â”€ reporter.ts       # æ•°æ®ä¸ŠæŠ¥
â”‚   â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ workers/                 # Web WorkeråŠŸèƒ½åŒ…
â”‚   â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”‚   â”œâ”€â”€ worker-pool.ts    # Workeræ± ç®¡ç†
â”‚   â”‚   â”‚   â”œâ”€â”€ file-worker.ts    # æ–‡ä»¶å¤„ç†Worker
â”‚   â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚   â”œâ”€â”€ dist/
â”‚   â”‚   â”‚   â””â”€â”€ workers/          # æ„å»ºåçš„Workerè„šæœ¬
â”‚   â”‚
â”‚   â”œâ”€â”€ standard/                # æ ‡å‡†åŠŸèƒ½æ•´åˆåŒ…
â”‚   â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”‚   â””â”€â”€ index.ts          # å¯¼å‡ºæ ‡å‡†åŠŸèƒ½é›†
â”‚   â”‚
â”‚   â”œâ”€â”€ full/                    # å®Œæ•´åŠŸèƒ½æ•´åˆåŒ…
â”‚   â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”‚   â””â”€â”€ index.ts          # å¯¼å‡ºæ‰€æœ‰åŠŸèƒ½
â”‚   â”‚
â”‚   â”œâ”€â”€ react/                   # Reacté€‚é…å™¨
â”‚   â”œâ”€â”€ vue/                     # Vueé€‚é…å™¨
â”‚   â””â”€â”€ vanilla/                 # åŸç”ŸJSé€‚é…å™¨
```

### 2. æ ¸å¿ƒAPIè®¾è®¡

#### æ’ä»¶åŒ–APIè®¾è®¡

```typescript
// åŸºæœ¬ä½¿ç”¨ç¤ºä¾‹ - æ’ä»¶åŒ–API
import { FileUploader } from '@file-chunk-uploader/core';
import { chunkUpload } from '@file-chunk-uploader/chunk';
import { resumable } from '@file-chunk-uploader/resume';
import { networkAdaptive } from '@file-chunk-uploader/network';

// åˆ›å»ºä¸Šä¼ å™¨å®ä¾‹
const uploader = new FileUploader({
  target: 'https://api.example.com/upload',
});

// ä½¿ç”¨æ’ä»¶æ‰©å±•åŠŸèƒ½
uploader.use(chunkUpload({ chunkSize: 2 * 1024 * 1024 }));
uploader.use(resumable({ storage: 'indexedDB' }));
uploader.use(networkAdaptive());

// å…¶ä»–APIä¿æŒä¸€è‡´
uploader
  .upload(fileObject)
  .then(result => console.log('ä¸Šä¼ å®Œæˆ', result))
  .catch(error => console.error('ä¸Šä¼ å¤±è´¥', error));

// æ§åˆ¶æ–¹æ³•
uploader.pause();
uploader.resume();
uploader.cancel();
```

#### æ•´åˆåŒ…APIï¼ˆç®€åŒ–ä½¿ç”¨ï¼‰

```typescript
// ä½¿ç”¨æ•´åˆåŒ…ç®€åŒ–é…ç½®
import { FileUploader } from '@file-chunk-uploader/standard';

const uploader = new FileUploader({
  target: 'https://api.example.com/upload',
  chunkSize: 2 * 1024 * 1024,
  concurrency: 3,
  retryCount: 3,
  checksum: true,
  resumable: true,
  onProgress: progress => console.log(`ä¸Šä¼ è¿›åº¦: ${progress}%`),
});

// åŒæ ·æ”¯æŒPromiseå’ŒObservable API
uploader.upload(fileObject).then(result => console.log('ä¸Šä¼ å®Œæˆ', result));

// å“åº”å¼API
uploader.uploadObservable(fileObject).subscribe({
  next: progress => console.log(`ä¸Šä¼ è¿›åº¦: ${progress}%`),
  complete: () => console.log('ä¸Šä¼ å®Œæˆ'),
});
```

### 3. æ’ä»¶ç³»ç»Ÿè®¾è®¡

æ¯ä¸ªæ’ä»¶éƒ½æ˜¯ä¸€ä¸ªç‹¬ç«‹çš„åŠŸèƒ½æ¨¡å—ï¼Œéµå¾ªç»Ÿä¸€çš„æ¥å£ï¼š

```typescript
// æ’ä»¶æ¥å£
interface Plugin {
  name: string;
  version: string;
  install: (uploader: FileUploaderCore, options?: any) => void;
  hooks?: Record<string, Function>;
  cleanup?: () => void;
}

// æ’ä»¶ç¤ºä¾‹
const chunkUploadPlugin = (options = {}): Plugin => ({
  name: 'chunk-upload',
  version: '1.0.0',
  install: (uploader, opts) => {
    const finalOptions = { ...options, ...opts };
    // å‘ä¸Šä¼ å™¨æ³¨å…¥åˆ†ç‰‡ä¸Šä¼ åŠŸèƒ½
    uploader.strategies.set('chunk', new ChunkUploadStrategy(finalOptions));
    // æ³¨å†Œé’©å­
    uploader.registerHook('beforeUpload', async file => {
      // å¤„ç†æ–‡ä»¶
      return file;
    });
  },
  hooks: {
    // å„ç”Ÿå‘½å‘¨æœŸé’©å­
    beforeUpload: file => {
      /* ... */
    },
    afterChunkUpload: (chunk, index) => {
      /* ... */
    },
  },
  cleanup: () => {
    // æ¸…ç†èµ„æº
  },
});
```

### 4. ä¾èµ–æ³¨å…¥ä¸é€‚é…å™¨æ¨¡å¼

ä¿æŒåŸæœ‰é€‚é…å™¨æ¨¡å¼è®¾è®¡ï¼Œé€šè¿‡æ’ä»¶ç³»ç»Ÿæ³¨å…¥é€‚é…å™¨ï¼š

```typescript
// ç½‘ç»œé€‚é…å™¨
import { FileUploader } from '@file-chunk-uploader/core';
import { networkPlugin } from '@file-chunk-uploader/network';
import { createFetchAdapter } from '@file-chunk-uploader/network/adapters';

const uploader = new FileUploader();
uploader.use(
  networkPlugin({
    adapter: createFetchAdapter(), // ä½¿ç”¨Fetché€‚é…å™¨
  }),
);

// ä¹Ÿå¯ä»¥ä½¿ç”¨XHRé€‚é…å™¨
import { createXhrAdapter } from '@file-chunk-uploader/network/adapters';
uploader.use(
  networkPlugin({
    adapter: createXhrAdapter(),
  }),
);

// æˆ–è‡ªå®šä¹‰é€‚é…å™¨
uploader.use(
  networkPlugin({
    adapter: {
      post: async (url, data, config) => {
        // è‡ªå®šä¹‰å®ç°
        return { success: true };
      },
      get: async (url, config) => {
        // è‡ªå®šä¹‰å®ç°
        return { data: [] };
      },
    },
  }),
);
```

### 4.1 åŠ¨æ€ä¸Šä¼ å‰©ä½™æ—¶é—´è®¡ç®—

å®ç°æ™ºèƒ½è®¡ç®—ä¸Šä¼ å‰©ä½™æ—¶é—´çš„å·¥å…·ç±»ï¼Œä½¿ç”¨ä¸‰é‡æƒé‡å¹³æ»‘ç®—æ³•å’Œè‡ªé€‚åº”å­¦ä¹ æœºåˆ¶ï¼š

```typescript
// @file-chunk-uploader/utils/src/etaCalculator.ts
export class ETACalculator {
  private samples: SpeedSample[] = [];
  private lastTotalSize = 0;
  private isNetworkIdle = true;
  private lastPrediction: number | null = null;
  private cachedWeightedSpeed: number | null = null;
  private lastWeightedCalcTime = 0;

  constructor(
    private readonly smoothingFactor = 0.7, // å¹³æ»‘ç³»æ•°
    private readonly maxSpeedDiff = 0.5, // æœ€å¤§æ³¢åŠ¨é˜ˆå€¼
  ) {}

  updateProgress(uploadedBytes: number, totalSize: number): void {
    const now = Date.now();

    // åˆå§‹åŒ–åœºæ™¯å¤„ç†
    if (this.samples.length === 0) {
      this.samples.push({ timestamp: now, bytes: uploadedBytes });
      this.lastTotalSize = totalSize;
      return;
    }

    // è®¡ç®—ç¬æ—¶é€Ÿåº¦
    const lastSample = this.samples[this.samples.length - 1];
    const timeDelta = (now - lastSample.timestamp) / 1000; // ç§’
    const byteDelta = uploadedBytes - lastSample.bytes;
    let currentSpeed = byteDelta / timeDelta;

    // å¼‚å¸¸å€¼è¿‡æ»¤
    if (this.samples.length >= 3) {
      const recentSpeeds = this.samples
        .slice(-3)
        .map((sample, idx, arr) => {
          if (idx === 0) return 0;
          return (
            (sample.bytes - arr[idx - 1].bytes) /
            ((sample.timestamp - arr[idx - 1].timestamp) / 1000)
          );
        })
        .filter(speed => speed > 0);

      const avgSpeed = recentSpeeds.reduce((a, b) => a + b, 0) / recentSpeeds.length;

      // è¿‡æ»¤å¼‚å¸¸å³°å€¼
      if (currentSpeed > avgSpeed * 3 || (avgSpeed > 0 && currentSpeed < avgSpeed * 0.2)) {
        currentSpeed = avgSpeed * (currentSpeed > avgSpeed ? 1.5 : 0.5);
      }
    }

    // æ£€æµ‹ç½‘ç»œä¸­æ–­åé‡è¿
    const timeSinceLastSample = now - lastSample.timestamp;
    if (timeSinceLastSample > 5000 && byteDelta > 0) {
      // é‡ç½®éƒ¨åˆ†å†å²æ•°æ®
      this.samples = this.samples.slice(-Math.min(3, this.samples.length));
      this.lastPrediction = null;
    }

    // ç½‘ç»œçŠ¶æ€æ£€æµ‹
    this.isNetworkIdle = byteDelta === 0;

    // æ·»åŠ æ–°æ ·æœ¬
    this.samples.push({ timestamp: now, bytes: uploadedBytes });

    // ç»´æŠ¤æ—¶é—´çª—å£
    if (this.samples.length > 15) {
      this.samples.shift();
    }

    this.lastTotalSize = totalSize;
  }

  calculateETA(): number | null {
    // è¾¹ç•Œæ¡ä»¶å¤„ç†
    if (this.isNetworkIdle) return null;
    if (this.samples.length < 3) return null;

    const totalRemaining = this.lastTotalSize - this.samples[this.samples.length - 1].bytes;
    if (totalRemaining <= 0) return 0;

    // è®¡ç®—ä¸‰é‡åŠ æƒé€Ÿåº¦
    const weightedSpeed = this.calculateWeightedSpeed();

    // åŠ¨æ€å­¦ä¹ ç³»æ•°
    const learningRate = this.calculateLearningRate();

    // åº”ç”¨è‡ªé€‚åº”å¹³æ»‘
    const adaptiveSpeed =
      learningRate * weightedSpeed + (1 - learningRate) * (this.lastPrediction || weightedSpeed);

    // å¤„ç†æä½é€Ÿåº¦åœºæ™¯
    if (adaptiveSpeed < 10) return null;

    // é¢„æµ‹å‰©ä½™æ—¶é—´ï¼ˆç§’ï¼‰
    const etaSeconds = totalRemaining / adaptiveSpeed;

    // å¤„ç†å‰©ä½™æ—¶é—´è¿‡å¤§çš„æƒ…å†µ
    if (etaSeconds > 24 * 3600) {
      return 24 * 3600; // æœ€å¤šæ˜¾ç¤º24å°æ—¶
    }

    // ä¿å­˜æœ¬æ¬¡é¢„æµ‹
    this.lastPrediction = adaptiveSpeed;

    return etaSeconds > 0 ? etaSeconds : null;
  }

  // æ ¼å¼åŒ–ETAä¸ºäººç±»å¯è¯»å­—ç¬¦ä¸²ï¼ˆHH:MM:SSï¼‰
  formatETA(seconds: number | null): string {
    if (seconds === null) return '--:--:--';

    const h = Math.floor(seconds / 3600);
    const m = Math.floor((seconds % 3600) / 60);
    const s = Math.floor(seconds % 60);

    return [h, m, s].map(v => v.toString().padStart(2, '0')).join(':');
  }

  private calculateWeightedSpeed(): number {
    const now = Date.now();

    // é¿å…é¢‘ç¹é‡æ–°è®¡ç®—ï¼ˆ1ç§’å†…å¤ç”¨ç»“æœï¼‰
    if (this.cachedWeightedSpeed && now - this.lastWeightedCalcTime < 1000) {
      return this.cachedWeightedSpeed;
    }

    const weights = [0.5, 0.3, 0.2]; // è¿‘ã€ä¸­ã€è¿œä¸‰é˜¶æ®µæƒé‡
    const segments = this.divideSamples(3);

    const result = segments.reduce((acc, segment, i) => {
      const segmentSpeed =
        segment.reduce((sum, sample, idx, arr) => {
          if (idx === 0) return 0;
          const timeDelta = (sample.timestamp - arr[idx - 1].timestamp) / 1000;
          const byteDelta = sample.bytes - arr[idx - 1].bytes;
          return sum + byteDelta / timeDelta;
        }, 0) / (segment.length - 1 || 1);

      return acc + segmentSpeed * weights[i];
    }, 0);

    // ç¼“å­˜è®¡ç®—ç»“æœ
    this.cachedWeightedSpeed = result;
    this.lastWeightedCalcTime = now;

    return result;
  }

  private divideSamples(segments: number): SpeedSample[][] {
    const segmentSize = Math.floor(this.samples.length / segments);
    const result = [];

    for (let i = 0; i < segments; i++) {
      const start = i * segmentSize;
      const end = i === segments - 1 ? this.samples.length : (i + 1) * segmentSize;
      result.push(this.samples.slice(start, end));
    }
    return result;
  }

  private calculateLearningRate(): number {
    if (this.samples.length < 5) return 0.5;

    // è®¡ç®—é€Ÿåº¦æ³¢åŠ¨ç‡
    const speeds: number[] = [];
    for (let i = 1; i < this.samples.length; i++) {
      const timeDelta = (this.samples[i].timestamp - this.samples[i - 1].timestamp) / 1000;
      const byteDelta = this.samples[i].bytes - this.samples[i - 1].bytes;
      speeds.push(byteDelta / timeDelta);
    }

    const maxSpeed = Math.max(...speeds);
    const minSpeed = Math.min(...speeds.filter(s => s > 0));
    const volatility = maxSpeed > 0 ? (maxSpeed - minSpeed) / maxSpeed : 0;

    // å¹³æ»‘è¿‡æ¸¡çš„å­¦ä¹ ç‡ï¼ˆé¿å…çªå˜ï¼‰
    const baseLearningRate = this.smoothingFactor;
    return Math.max(0.3, baseLearningRate * (1 - volatility * 0.7));
  }
}
```

ä¸Šä¼ å¼•æ“ä¸­é›†æˆè¯¥åŠŸèƒ½ï¼š

```typescript
// @file-chunk-uploader/core/src/upload-engine.ts
import { ETACalculator } from '@file-chunk-uploader/utils';

export class UploadEngine {
  private etaCalculator = new ETACalculator();
  // ...å…¶ä»–å±æ€§

  private async processUpload() {
    // ...ä¸Šä¼ é€»è¾‘

    // ä¸Šä¼ è¿›åº¦å›è°ƒä¸­
    onProgress: (uploaded: number, total: number) => {
      this.etaCalculator.updateProgress(uploaded, total);
      const etaSeconds = this.etaCalculator.calculateETA();
      const eta = this.etaCalculator.formatETA(etaSeconds);

      this.emit('progress', {
        uploaded,
        total,
        percentage: Math.round((uploaded / total) * 100),
        eta,
        etaSeconds,
      });

      // å¼€å‘è€…æ¨¡å¼æ—¥å¿—
      if (this.config.devMode?.enabled) {
        this.logger.debug(
          `ä¸Šä¼ è¿›åº¦: ${Math.round((uploaded / total) * 100)}%, é¢„è®¡å‰©ä½™æ—¶é—´: ${eta}`,
          null,
          'core'
        );

        // è¯¦ç»†é¢„æµ‹åˆ†ææ—¥å¿—
        if (etaSeconds !== null) {
          this.logPredictionDetails();
        }
      }
    };
  }

  // è®°å½•è¯¦ç»†çš„é¢„æµ‹åˆ†ææ—¥å¿—
  private logPredictionDetails(): void {
    if (!this.config.devMode?.enabled) return;

    const details = this.etaCalculator.getPredictionDetails();

    console.groupCollapsed('[UPLOADER-ETA] é¢„æµ‹è¯¦æƒ…');
    console.log(`æ ·æœ¬æ•°é‡: ${details.samples}`);
    console.log(`åŠ æƒé€Ÿåº¦: ${details.weightedSpeed.toFixed(2)} B/s`);
    console.log(`å­¦ä¹ ç‡: ${details.learningRate.toFixed(2)}`);
    console.log(`è®¡ç®—çš„ETA: ${details.etaSeconds} ç§’`);
    console.log(`åº”ç”¨çš„è¿‡æ»¤å™¨: ${details.filtersApplied.join(', ') || 'æ— '}`);

    // æ·»åŠ ç½‘ç»œæ¨¡å¼åˆ†æ
    if (details.samples >= 10) {
      console.log('ğŸ“ˆ ç½‘ç»œæ¨¡å¼: ç¨³å®š');
    } else if (details.samples >= 5) {
      console.log('ğŸ“Š ç½‘ç»œæ¨¡å¼: æ­£åœ¨ç¨³å®š');
    } else {
      console.log('ğŸŒ ç½‘ç»œæ¨¡å¼: åˆå§‹åŒ–ä¸­');
    }

    // æ˜¾ç¤ºé€Ÿåº¦ç¨³å®šæ€§
    console.log(`é€Ÿåº¦æ³¢åŠ¨ç‡: ${(details.volatility * 100).toFixed(1)}%`);
    console.log(`æœ€å¤§æ³¢åŠ¨é˜ˆå€¼: ${(this.etaCalculator.getMaxSpeedDiff() * 100).toFixed(1)}%`);

    // æ˜¾ç¤ºé€Ÿåº¦å›¾è¡¨
    if (details.speedHistory?.length > 0) {
      console.log('é€Ÿåº¦å˜åŒ–å›¾:');
      console.log(this.generateSpeedChart(details.speedHistory));
    }

    console.groupEnd();
  }

  // ç”Ÿæˆç®€å•çš„é€Ÿåº¦å›¾è¡¨
  private generateSpeedChart(speedHistory: number[]): string {
    if (!speedHistory.length) return '';

    const max = Math.max(...speedHistory);
    const min = Math.min(...speedHistory);
    const range = max - min || 1;
    const height = 5; // å›¾è¡¨é«˜åº¦

    let chart = '';
    for (const speed of speedHistory) {
      const normalized = Math.round(((speed - min) / range) * (height - 1));
      const bar = 'â–â–‚â–ƒâ–„â–…â–†â–‡â–ˆ'[normalized] || 'â–';
      chart += bar;
    }

    return chart;
  }
}

// @file-chunk-uploader/utils/src/etaCalculator.ts
export class ETACalculator {
  // ... ç°æœ‰ä»£ç 

  // è·å–é¢„æµ‹è¯¦æƒ…ï¼Œç”¨äºå¼€å‘è€…æ¨¡å¼
  getPredictionDetails(): PredictionDetails {
    const lastSample = this.samples[this.samples.length - 1] || { bytes: 0, timestamp: 0 };
    const weightedSpeed = this.cachedWeightedSpeed || this.calculateWeightedSpeed();
    const learningRate = this.calculateLearningRate();
    const adaptiveSpeed =
      learningRate * weightedSpeed +
      (1 - learningRate) * (this.lastPrediction || weightedSpeed);

    const totalRemaining = this.lastTotalSize - lastSample.bytes;
    const etaSeconds = totalRemaining / adaptiveSpeed;

    // è®¡ç®—é€Ÿåº¦å†å²
    const speedHistory: number[] = [];
    for (let i = 1; i < this.samples.length; i++) {
      const timeDelta = (this.samples[i].timestamp - this.samples[i-1].timestamp) / 1000;
      const byteDelta = this.samples[i].bytes - this.samples[i-1].bytes;
      if (timeDelta > 0) {
        speedHistory.push(byteDelta / timeDelta);
      }
    }

    // è®¡ç®—è¿‡æ»¤å™¨åº”ç”¨æƒ…å†µ
    const filtersApplied: string[] = [];
    if (this.isNetworkIdle) filtersApplied.push('ç½‘ç»œç©ºé—²');
    if (this.samples.length < 3) filtersApplied.push('æ ·æœ¬ä¸è¶³');
    if (adaptiveSpeed < 10) filtersApplied.push('é€Ÿåº¦æä½');

    // è®¡ç®—æ³¢åŠ¨ç‡
    let volatility = 0;
    if (speedHistory.length > 1) {
      const maxSpeed = Math.max(...speedHistory);
      const minSpeed = Math.min(...speedHistory);
      volatility = maxSpeed > 0 ? (maxSpeed - minSpeed) / maxSpeed : 0;
    }

    return {
      samples: this.samples.length,
      weightedSpeed,
      adaptiveSpeed,
      learningRate,
      etaSeconds,
      filtersApplied,
      volatility,
      speedHistory,
    };
  }

  // è·å–é…ç½®å‚æ•°
  getMaxSpeedDiff(): number {
    return this.maxSpeedDiff;
  }

  // å®šä¹‰æ¥å£
  interface PredictionDetails {
    samples: number;
    weightedSpeed: number;
    adaptiveSpeed: number;
    learningRate: number;
    etaSeconds: number;
    filtersApplied: string[];
    volatility: number;
    speedHistory: number[];
  }
}
```

### 5. å·¥ä½œæµç¨‹è®¾è®¡

ä¸åŸè®¾è®¡ä¿æŒä¸€è‡´ã€‚

### 6. å¤šæ¡†æ¶é€‚é…è®¾è®¡

å¢åŠ SSRæ”¯æŒè¯´æ˜ï¼š

```typescript
// Reacté€‚é…å™¨å¢åŠ SSRæ”¯æŒ
// @file-chunk-uploader/react

import { useState, useEffect, useRef } from 'react';
import { FileUploaderCore } from '@file-chunk-uploader/core';

// SSRå®‰å…¨çš„React Hook
export function useFileUploader(config) {
  const [progress, setProgress] = useState(0);
  const [status, setStatus] = useState('idle');
  const [error, setError] = useState(null);
  const uploaderRef = useRef(null);

  useEffect(() => {
    // ä»…åœ¨å®¢æˆ·ç«¯ç¯å¢ƒåˆ›å»ºä¸Šä¼ å™¨å®ä¾‹
    if (typeof window !== 'undefined') {
      const uploader = new FileUploaderCore({
        ...config,
        onProgress: p => {
          setProgress(p);
          config?.onProgress?.(p);
        },
        onStatusChange: s => {
          setStatus(s);
          config?.onStatusChange?.(s);
        },
        onError: e => {
          setError(e);
          config?.onError?.(e);
        },
      });

      uploaderRef.current = uploader;

      return () => {
        uploader.cancel();
      };
    }
  }, []);

  // SSRå®‰å…¨çš„APIè°ƒç”¨
  const upload = file => {
    if (uploaderRef.current) {
      return uploaderRef.current.upload(file);
    }
    return Promise.reject(new Error('ä¸Šä¼ å™¨æœªåˆå§‹åŒ–æˆ–åœ¨æœåŠ¡å™¨ç«¯ç¯å¢ƒ'));
  };

  // å…¶ä»–æ–¹æ³•ç±»ä¼¼å®ç°...

  return {
    uploader: uploaderRef.current,
    progress,
    status,
    error,
    upload,
    pause: () => uploaderRef.current?.pause(),
    resume: () => uploaderRef.current?.resume(),
    cancel: () => uploaderRef.current?.cancel(),
  };
}
```

### 7. Web Workerå¢å¼ºè®¾è®¡

å¢åŠ æ‡’åŠ è½½å’Œé™çº§ç­–ç•¥ï¼š

```typescript
// Web Workeræ± ä¼˜åŒ–å®ç°
class FileProcessingWorkerPool {
  workers: Worker[] = [];
  taskQueue: Task[] = [];
  activeWorkers: Map<Worker, Task> = new Map();
  isSupported: boolean;
  isInitialized: boolean = false;

  constructor(options = { poolSize: navigator.hardwareConcurrency || 4, lazyInit: true }) {
    // æ£€æµ‹æµè§ˆå™¨æ˜¯å¦æ”¯æŒWeb Worker
    this.isSupported = typeof Worker !== 'undefined';

    // å¦‚æœä¸æ”¯æŒWorkerï¼Œä¸åˆ›å»ºworkeræ± 
    if (!this.isSupported) {
      console.warn('Web Workersä¸å—æ”¯æŒï¼Œå°†ä½¿ç”¨ä¸»çº¿ç¨‹å¤„ç†');
      return;
    }

    // æ‡’åŠ è½½æ¨¡å¼ï¼Œä»…åœ¨éœ€è¦æ—¶åˆå§‹åŒ–workers
    if (!options.lazyInit) {
      this.initialize(options.poolSize);
    }
  }

  // æ‡’åŠ è½½åˆå§‹åŒ–
  private initialize(poolSize: number): void {
    if (this.isInitialized || !this.isSupported) return;

    for (let i = 0; i < poolSize; i++) {
      try {
        const worker = new Worker(new URL('../workers/file-worker.ts', import.meta.url), {
          type: 'module',
        });

        worker.onmessage = e => this.handleWorkerResult(worker, e.data);
        this.workers.push(worker);
      } catch (err) {
        console.error('åˆ›å»ºWorkerå¤±è´¥:', err);
        this.isSupported = false;
        break;
      }
    }

    this.isInitialized = this.workers.length > 0;

    // å¦‚æœåˆå§‹åŒ–æˆåŠŸï¼Œå¤„ç†é˜Ÿåˆ—ä¸­å¾…å¤„ç†çš„ä»»åŠ¡
    if (this.isInitialized && this.taskQueue.length > 0) {
      this.processQueue();
    }
  }

  // å¤„ç†é˜Ÿåˆ—ä¸­çš„ä»»åŠ¡
  private processQueue(): void {
    while (this.taskQueue.length > 0 && this.getIdleWorker()) {
      const task = this.taskQueue.shift();
      if (task) {
        const worker = this.getIdleWorker();
        if (worker) {
          this.assignTaskToWorker(worker, task);
        }
      }
    }
  }

  // è·å–ç©ºé—²worker
  private getIdleWorker(): Worker | null {
    return this.workers.find(w => !this.activeWorkers.has(w)) || null;
  }

  // è°ƒåº¦ä»»åŠ¡ï¼ˆæ”¯æŒWorkeré™çº§ï¼‰
  private scheduleTask(task: Task): Promise<any> {
    return new Promise((resolve, reject) => {
      // ä»»åŠ¡æ·»åŠ ç»“æœå›è°ƒ
      task.resolve = resolve;
      task.reject = reject;

      // å¦‚æœWeb Workerä¸å—æ”¯æŒæˆ–åˆå§‹åŒ–å¤±è´¥ï¼Œåœ¨ä¸»çº¿ç¨‹ä¸Šæ‰§è¡Œ
      if (!this.isSupported) {
        this.executeOnMainThread(task);
        return;
      }

      // æ‡’åŠ è½½åˆå§‹åŒ–
      if (!this.isInitialized) {
        this.initialize(navigator.hardwareConcurrency || 4);
      }

      // å°è¯•æ‰¾ç©ºé—²worker
      const idleWorker = this.getIdleWorker();

      if (idleWorker) {
        this.assignTaskToWorker(idleWorker, task);
      } else {
        // æ²¡æœ‰ç©ºé—²workerï¼ŒåŠ å…¥é˜Ÿåˆ—
        this.taskQueue.push(task);

        // å†…å­˜ç®¡ç†ï¼šæ£€æŸ¥é˜Ÿåˆ—é•¿åº¦ï¼Œé¿å…å†…å­˜æº¢å‡º
        if (this.taskQueue.length > 100) {
          // è®¾ç½®åˆç†çš„ä¸Šé™
          const oldestTask = this.taskQueue.shift();
          oldestTask?.reject(new Error('ä»»åŠ¡é˜Ÿåˆ—æº¢å‡ºï¼Œä»»åŠ¡è¢«å–æ¶ˆ'));
        }
      }
    });
  }

  // ä¸»çº¿ç¨‹ä¸Šæ‰§è¡Œä»»åŠ¡ï¼ˆé™çº§ç­–ç•¥ï¼‰
  private async executeOnMainThread(task: Task): Promise<void> {
    try {
      let result;

      switch (task.type) {
        case 'hash':
          result = await this.calculateHashInMainThread(task.payload.file, task.payload.algorithm);
          break;

        case 'chunk':
          result = await this.createChunksInMainThread(task.payload.file, task.payload.chunkSize);
          break;

        // å®ç°å…¶ä»–ä»»åŠ¡ç±»å‹çš„ä¸»çº¿ç¨‹å¤„ç†...

        default:
          throw new Error(`æœªçŸ¥ä»»åŠ¡ç±»å‹: ${task.type}`);
      }

      task.resolve(result);
    } catch (err) {
      task.reject(err);
    }
  }

  // ä¸»çº¿ç¨‹è®¡ç®—å“ˆå¸Œå®ç°ï¼ˆé™çº§ï¼‰
  private async calculateHashInMainThread(file: File, algorithm: string): Promise<string> {
    // æµå¼è¯»å–å¤§æ–‡ä»¶ï¼Œé¿å…å†…å­˜é—®é¢˜
    const chunkSize = 2 * 1024 * 1024; // 2MBå—
    const crypto = window.crypto.subtle;
    let hashContext;

    try {
      hashContext = await crypto.digest(algorithm, new ArrayBuffer(0));
    } catch (e) {
      // é™çº§åˆ°ç®€å•å“ˆå¸Œç®—æ³•
      return this.calculateSimpleHash(file);
    }

    // æµå¼å¤„ç†å®ç°...
    return 'hash-placeholder';
  }

  // ç®€å•å“ˆå¸Œç®—æ³•ï¼ˆæœ€ç»ˆé™çº§ï¼‰
  private calculateSimpleHash(file: File): string {
    return `${file.name}-${file.size}-${file.lastModified}`;
  }

  // ä¸»çº¿ç¨‹åˆ†ç‰‡å®ç°ï¼ˆé™çº§ï¼‰
  private async createChunksInMainThread(file: File, chunkSize: number): Promise<Blob[]> {
    // é¿å…ä¸€æ¬¡æ€§åˆ›å»ºæ‰€æœ‰åˆ†ç‰‡å¯¼è‡´å†…å­˜é—®é¢˜
    const totalChunks = Math.ceil(file.size / chunkSize);
    const chunkRefs = [];

    for (let i = 0; i < totalChunks; i++) {
      const start = i * chunkSize;
      const end = Math.min(start + chunkSize, file.size);
      chunkRefs.push({ start, end });
    }

    return chunkRefs.map(ref => file.slice(ref.start, ref.end));
  }

  // å…¶ä»–æ–¹æ³•ä¿æŒä¸å˜...
}
```

### 8. é”™è¯¯å¤„ç†ç³»ç»Ÿ

å¢å¼ºçš„é”™è¯¯æ¢å¤æœºåˆ¶ï¼š

```typescript
// å¢å¼ºçš„é”™è¯¯å¤„ç†å™¨
class ErrorHandler {
  private config: ErrorHandlerConfig;
  private metricsCollector: MetricsCollector;

  constructor(config: ErrorHandlerConfig, metricsCollector: MetricsCollector) {
    this.config = config;
    this.metricsCollector = metricsCollector;
  }

  handle(error: UploadError, context: ErrorContext): ErrorAction {
    // è®°å½•é”™è¯¯æŒ‡æ ‡
    this.metricsCollector.recordError(error, context);

    // å®ç°æ™ºèƒ½é”™è¯¯æ¢å¤ç­–ç•¥
    if (error.retryable && context.retryCount < this.config.maxRetries) {
      const retryDelay = this.calculateRetryDelay(context.retryCount);

      return {
        type: 'retry',
        delay: retryDelay,
        message: `å°†åœ¨${retryDelay / 1000}ç§’åé‡è¯•ï¼ˆ${context.retryCount + 1}/${
          this.config.maxRetries
        }ï¼‰`,
      };
    }

    // ç‰¹å®šé”™è¯¯ç±»å‹çš„æ¢å¤ç­–ç•¥
    switch (error.code) {
      case 'network_disconnect':
        return {
          type: 'wait_for_connection',
          message: 'ç­‰å¾…ç½‘ç»œè¿æ¥æ¢å¤...',
        };

      case 'server_overload':
        return {
          type: 'retry',
          delay: 30000, // 30ç§’ç‰¹æ®Šå»¶è¿Ÿ
          message: 'æœåŠ¡å™¨ç¹å¿™ï¼Œå°†åœ¨30ç§’åé‡è¯•',
        };

      case 'quota_exceeded':
        return {
          type: 'fail',
          recoverable: false,
          message: 'å­˜å‚¨é…é¢å·²æ»¡ï¼Œæ— æ³•ç»§ç»­ä¸Šä¼ ',
        };

      case 'invalid_chunk_size':
        return {
          type: 'adjust_and_retry',
          newChunkSize: Math.floor(context.chunkSize / 2),
          message: 'åˆ†ç‰‡å¤§å°è°ƒæ•´åé‡è¯•',
        };

      default:
        return {
          type: 'fail',
          recoverable: error.retryable,
          message: error.message,
        };
    }
  }

  // å®ç°æŒ‡æ•°é€€é¿ç®—æ³•
  private calculateRetryDelay(retryCount: number): number {
    const baseDelay = 1000; // 1ç§’
    const maxDelay = 30000; // 30ç§’
    const jitter = Math.random() * 1000; // 0-1000mséšæœºæŠ–åŠ¨

    const exponentialDelay = baseDelay * Math.pow(2, retryCount);
    return Math.min(exponentialDelay + jitter, maxDelay);
  }

  // é”™è¯¯èšåˆä¸æŠ¥å‘Š
  aggregateErrors(timeWindow: number = 60000): ErrorReport {
    return this.metricsCollector.getErrorSummary(timeWindow);
  }
}

// é”™è¯¯æ¢å¤ç®¡ç†å™¨
class ErrorRecoveryManager {
  private errorHandler: ErrorHandler;
  private networkDetector: NetworkDetector;
  private recoveryQueue: Map<string, RecoveryTask> = new Map();
  private storageManager: StorageManager;
  private retryHistory: Map<string, RetryStats> = new Map();
  private eventEmitter: EventEmitter;

  constructor(
    errorHandler: ErrorHandler,
    networkDetector: NetworkDetector,
    storageManager: StorageManager,
    eventEmitter: EventEmitter,
  ) {
    this.errorHandler = errorHandler;
    this.networkDetector = networkDetector;
    this.storageManager = storageManager;
    this.eventEmitter = eventEmitter;

    // ç›‘å¬ç½‘ç»œçŠ¶æ€å˜åŒ–
    this.networkDetector.onNetworkChange(network => {
      if (network.online) {
        this.processRecoveryQueue();
      }
    });

    // åˆå§‹åŒ–æ—¶ä»å­˜å‚¨ä¸­æ¢å¤é‡è¯•çŠ¶æ€
    this.loadRetryStates();
  }

  // å¤„ç†é”™è¯¯å¹¶å®‰æ’æ¢å¤
  async handleError(error: UploadError, context: ErrorContext): Promise<void> {
    const action = this.errorHandler.handle(error, context);

    // æ›´æ–°é”™è¯¯ç»Ÿè®¡ï¼Œç”¨äºæ™ºèƒ½å†³ç­–
    this.updateErrorStats(error, context);

    switch (action.type) {
      case 'retry':
        // å‘é€é‡è¯•å¼€å§‹äº‹ä»¶
        this.eventEmitter.emit('retry:start', {
          fileId: context.fileId,
          chunkIndex: context.chunkIndex,
          retryCount: context.retryCount,
          delay: action.delay,
          error,
        });

        await this.scheduleRetry(context, action.delay);
        break;

      case 'wait_for_connection':
        this.eventEmitter.emit('retry:waiting', {
          fileId: context.fileId,
          reason: 'network_disconnect',
        });

        this.queueForNetworkRecovery(context);
        break;

      case 'adjust_and_retry':
        this.eventEmitter.emit('retry:adjusting', {
          fileId: context.fileId,
          chunkIndex: context.chunkIndex,
          oldChunkSize: context.chunkSize,
          newChunkSize: action.newChunkSize,
        });

        await this.adjustAndRetry(context, action);
        break;

      case 'fail':
        // å‘é€é‡è¯•å¤±è´¥äº‹ä»¶
        this.eventEmitter.emit('retry:failed', {
          fileId: context.fileId,
          error,
          recoverable: action.recoverable,
        });

        this.handleFailure(context, action, error);
        break;
    }

    // æŒä¹…åŒ–é‡è¯•çŠ¶æ€
    await this.saveRetryState(context);
  }

  // ä¿å­˜é‡è¯•çŠ¶æ€åˆ°æŒä¹…åŒ–å­˜å‚¨
  private async saveRetryState(context: ErrorContext): Promise<void> {
    if (!context.fileId) return;

    const retryState = {
      fileId: context.fileId,
      retryCount: context.retryCount,
      lastRetryTime: Date.now(),
      chunkRetries: context.chunkRetries || {},
      successfulRetries: context.successfulRetries || 0,
      failedRetries: context.failedRetries || 0,
    };

    try {
      await this.storageManager.saveRetryState(context.fileId, retryState);
    } catch (err) {
      console.warn('ä¿å­˜é‡è¯•çŠ¶æ€å¤±è´¥', err);
    }
  }

  // ä»æŒä¹…åŒ–å­˜å‚¨åŠ è½½é‡è¯•çŠ¶æ€
  private async loadRetryStates(): Promise<void> {
    try {
      const activeUploads = await this.storageManager.getActiveUploads();

      for (const fileId of activeUploads) {
        const retryState = await this.storageManager.getRetryState(fileId);
        if (retryState) {
          this.retryHistory.set(fileId, {
            successCount: retryState.successfulRetries || 0,
            failCount: retryState.failedRetries || 0,
            lastRetryTime: retryState.lastRetryTime,
            networkConditions: [],
          });
        }
      }
    } catch (err) {
      console.warn('åŠ è½½é‡è¯•çŠ¶æ€å¤±è´¥', err);
    }
  }

  // æ›´æ–°é”™è¯¯ç»Ÿè®¡ä¿¡æ¯
  private updateErrorStats(error: UploadError, context: ErrorContext): void {
    const fileId = context.fileId;
    if (!fileId) return;

    let stats = this.retryHistory.get(fileId);
    if (!stats) {
      stats = {
        successCount: 0,
        failCount: 0,
        lastRetryTime: 0,
        networkConditions: [],
      };
      this.retryHistory.set(fileId, stats);
    }

    // è®°å½•å½“å‰ç½‘ç»œçŠ¶å†µ
    const networkInfo = this.networkDetector.getCurrentNetwork();
    stats.networkConditions.push({
      time: Date.now(),
      online: networkInfo.online,
      type: networkInfo.type,
      speed: networkInfo.speed,
      rtt: networkInfo.rtt,
    });

    // ä¿ç•™æœ€è¿‘10æ¡è®°å½•
    if (stats.networkConditions.length > 10) {
      stats.networkConditions.shift();
    }
  }

  // æ™ºèƒ½å†³ç­–æ˜¯å¦å€¼å¾—é‡è¯•
  private shouldRetry(context: ErrorContext): boolean {
    const fileId = context.fileId;
    if (!fileId) return true; // é»˜è®¤é‡è¯•

    const stats = this.retryHistory.get(fileId);
    if (!stats) return true;

    // 1. å¦‚æœæˆåŠŸç‡è¿‡ä½ï¼Œå¯èƒ½ä¸å€¼å¾—é‡è¯•
    const totalAttempts = stats.successCount + stats.failCount;
    if (totalAttempts > 5 && stats.successCount / totalAttempts < 0.2) {
      return false; // æˆåŠŸç‡ä½äº20%ï¼Œä¸å†é‡è¯•
    }

    // 2. åŸºäºç½‘ç»œè´¨é‡å†³å®šæ˜¯å¦é‡è¯•
    const recentConditions = stats.networkConditions.slice(-3); // æœ€è¿‘3æ¬¡ç½‘ç»œçŠ¶å†µ
    if (recentConditions.length >= 3) {
      // å¦‚æœè¿ç»­3æ¬¡ç½‘ç»œçŠ¶å†µå¾ˆå·®ï¼Œæš‚åœé‡è¯•
      const allPoorConditions = recentConditions.every(
        c => !c.online || c.speed < 0.5 || c.rtt > 1000,
      );

      if (allPoorConditions) {
        return false;
      }
    }

    return true;
  }

  // é‡è¯•æˆåŠŸå¤„ç†
  async handleRetrySuccess(context: ErrorContext): Promise<void> {
    const fileId = context.fileId;
    if (!fileId) return;

    // æ›´æ–°ç»Ÿè®¡
    const stats = this.retryHistory.get(fileId) || {
      successCount: 0,
      failCount: 0,
      lastRetryTime: 0,
      networkConditions: [],
    };

    stats.successCount++;
    this.retryHistory.set(fileId, stats);

    // æ›´æ–°æŒä¹…åŒ–å­˜å‚¨
    const retryState = (await this.storageManager.getRetryState(fileId)) || {
      fileId,
      retryCount: 0,
      lastRetryTime: Date.now(),
      chunkRetries: {},
      successfulRetries: 0,
      failedRetries: 0,
    };

    retryState.successfulRetries++;
    await this.storageManager.saveRetryState(fileId, retryState);

    // å‘é€é‡è¯•æˆåŠŸäº‹ä»¶
    this.eventEmitter.emit('retry:success', {
      fileId,
      chunkIndex: context.chunkIndex,
      successCount: stats.successCount,
    });
  }

  // æ›´å¤šæ¢å¤æ–¹æ³•å®ç°...
}
```

### 9. æ’ä»¶ç³»ç»Ÿ

å¢å¼ºçš„æ’ä»¶ç”Ÿå‘½å‘¨æœŸç®¡ç†ï¼š

```typescript
// å¢å¼ºçš„æ’ä»¶ç³»ç»Ÿ
interface PluginLifecycle {
  init?: (uploader: FileUploaderCore) => void | Promise<void>;
  beforeUpload?: (file: File, config: UploadConfig) => File | Promise<File>;
  beforeChunkUpload?: (chunk: Blob, index: number, total: number) => Blob | Promise<Blob>;
  afterChunkUpload?: (response: any, chunk: Blob, index: number) => void | Promise<void>;
  afterUpload?: (result: UploadResult) => void | Promise<void>;
  onError?: (error: UploadError) => boolean | Promise<boolean>; // è¿”å›trueè¡¨ç¤ºé”™è¯¯å·²å¤„ç†
  onPause?: () => void | Promise<void>;
  onResume?: () => void | Promise<void>;
  onCancel?: () => void | Promise<void>;
  onProgress?: (progress: number) => void | Promise<void>;
  onRetryStart?: (retryInfo: RetryStartInfo) => void | Promise<void>; // é‡è¯•å¼€å§‹äº‹ä»¶
  onRetrySuccess?: (retryInfo: RetrySuccessInfo) => void | Promise<void>; // é‡è¯•æˆåŠŸäº‹ä»¶
  onRetryFailed?: (retryInfo: RetryFailedInfo) => void | Promise<void>; // é‡è¯•å¤±è´¥äº‹ä»¶
  cleanup?: () => void | Promise<void>;
}

class PluginManager {
  private plugins: Map<string, Plugin> = new Map();
  private uploader: FileUploaderCore;
  private lifecycleOrder: Record<keyof PluginLifecycle, 'sequential' | 'parallel'> = {
    init: 'sequential',
    beforeUpload: 'sequential',
    beforeChunkUpload: 'sequential',
    afterChunkUpload: 'parallel',
    afterUpload: 'parallel',
    onError: 'sequential',
    onPause: 'parallel',
    onResume: 'parallel',
    onCancel: 'parallel',
    onProgress: 'parallel',
    onRetryStart: 'parallel',
    onRetrySuccess: 'parallel',
    onRetryFailed: 'parallel',
    cleanup: 'sequential',
  };

  constructor(uploader: FileUploaderCore) {
    this.uploader = uploader;
  }

  register(plugin: Plugin): void {
    if (this.plugins.has(plugin.name)) {
      throw new Error(`æ’ä»¶ "${plugin.name}" å·²æ³¨å†Œ`);
    }

    this.plugins.set(plugin.name, plugin);

    // å¦‚æœæ’ä»¶æœ‰åˆå§‹åŒ–æ–¹æ³•ï¼Œç«‹å³æ‰§è¡Œ
    if (plugin.lifecycle?.init) {
      plugin.lifecycle.init(this.uploader);
    }
  }

  unregister(pluginName: string): boolean {
    const plugin = this.plugins.get(pluginName);
    if (!plugin) return false;

    // æ‰§è¡Œæ’ä»¶æ¸…ç†
    if (plugin.lifecycle?.cleanup) {
      plugin.lifecycle.cleanup();
    }

    return this.plugins.delete(pluginName);
  }

  // è°ƒç”¨æŒ‡å®šç”Ÿå‘½å‘¨æœŸé’©å­
  async invokeHook<T>(
    hookName: keyof PluginLifecycle,
    initialValue: T,
    ...args: any[]
  ): Promise<T> {
    const plugins = Array.from(this.plugins.values());
    const executionMode = this.lifecycleOrder[hookName];

    if (executionMode === 'sequential') {
      // é¡ºåºæ‰§è¡Œ
      let result = initialValue;
      for (const plugin of plugins) {
        const hook = plugin.lifecycle?.[hookName] as Function;
        if (hook) {
          result = await hook.call(plugin, result, ...args);
        }
      }
      return result;
    } else {
      // å¹¶è¡Œæ‰§è¡Œ
      await Promise.all(
        plugins.map(plugin => {
          const hook = plugin.lifecycle?.[hookName] as Function;
          return hook?.call(plugin, ...args);
        }),
      );
      return initialValue;
    }
  }

  // å®ç°æ’ä»¶APIç‰ˆæœ¬å…¼å®¹æ€§æ£€æŸ¥
  checkCompatibility(plugin: Plugin): boolean {
    const requiredVersion = plugin.apiVersion || '1.0.0';
    const currentVersion = this.uploader.apiVersion;

    // å®ç°è¯­ä¹‰åŒ–ç‰ˆæœ¬æ¯”è¾ƒ
    return this.isVersionCompatible(currentVersion, requiredVersion);
  }

  private isVersionCompatible(current: string, required: string): boolean {
    // è¯­ä¹‰åŒ–ç‰ˆæœ¬æ¯”è¾ƒå®ç°
    return true; // ç®€åŒ–å®ç°
  }
}
```

### 10. å®‰å…¨è®¾è®¡

å¢å¼ºçš„å®‰å…¨æ¨¡å—ï¼š

```typescript
// å¢å¼ºçš„å®‰å…¨æ¨¡å—
class SecurityManager {
  private config: SecurityConfig;

  constructor(config: SecurityConfig) {
    this.config = {
      maxFileSize: 1024 * 1024 * 1024, // 1GB
      allowedMimeTypes: ['*/*'],
      disallowedMimeTypes: [],
      scanFileContent: false,
      validateHash: false,
      ...config,
    };
  }

  // å…¨é¢çš„æ–‡ä»¶éªŒè¯
  async validateFile(file: File): Promise<ValidationResult> {
    // åŸºæœ¬éªŒè¯
    if (!file) {
      return { valid: false, reason: 'file_missing' };
    }

    // æ–‡ä»¶å¤§å°éªŒè¯
    if (file.size > this.config.maxFileSize) {
      return {
        valid: false,
        reason: 'file_too_large',
        details: {
          size: file.size,
          maxSize: this.config.maxFileSize,
        },
      };
    }

    // MIMEç±»å‹éªŒè¯
    if (!this.isValidMimeType(file.type)) {
      return {
        valid: false,
        reason: 'invalid_mime_type',
        details: { type: file.type },
      };
    }

    // æ–‡ä»¶æ‰©å±•åéªŒè¯
    if (!this.isValidExtension(file.name)) {
      return {
        valid: false,
        reason: 'invalid_extension',
        details: { name: file.name },
      };
    }

    // æ–‡ä»¶å†…å®¹æ‰«æï¼ˆå¯é€‰ï¼‰
    if (this.config.scanFileContent) {
      const contentResult = await this.scanContent(file);
      if (!contentResult.valid) {
        return contentResult;
      }
    }

    return { valid: true };
  }

  // MIMEç±»å‹éªŒè¯
  private isValidMimeType(mimeType: string): boolean {
    // å¦‚æœåœ¨ç¦æ­¢åˆ—è¡¨ä¸­ï¼Œç›´æ¥æ‹’ç»
    if (this.config.disallowedMimeTypes.some(pattern => this.matchMimePattern(mimeType, pattern))) {
      return false;
    }

    // å¦‚æœå…è®¸åˆ—è¡¨ä¸º ['*/*'] è¡¨ç¤ºå…è®¸æ‰€æœ‰ç±»å‹
    if (this.config.allowedMimeTypes.includes('*/*')) {
      return true;
    }

    // æ£€æŸ¥æ˜¯å¦åœ¨å…è®¸åˆ—è¡¨ä¸­
    return this.config.allowedMimeTypes.some(pattern => this.matchMimePattern(mimeType, pattern));
  }

  // MIMEæ¨¡å¼åŒ¹é…
  private matchMimePattern(mimeType: string, pattern: string): boolean {
    if (pattern === '*/*') return true;

    const [typePattern, subtypePattern] = pattern.split('/');
    const [type, subtype] = mimeType.split('/');

    const typeMatch = typePattern === '*' || typePattern === type;
    const subtypeMatch = subtypePattern === '*' || subtypePattern === subtype;

    return typeMatch && subtypeMatch;
  }

  // æ–‡ä»¶æ‰©å±•åéªŒè¯
  private isValidExtension(filename: string): boolean {
    if (!this.config.allowedExtensions) return true;

    const extension = filename.split('.').pop()?.toLowerCase() || '';
    return this.config.allowedExtensions.includes(extension);
  }

  // æ–‡ä»¶å†…å®¹æ‰«æ
  private async scanContent(file: File): Promise<ValidationResult> {
    // æ–‡ä»¶å¤´éƒ¨ç­¾åæ£€æŸ¥
    const headerResult = await this.checkFileHeader(file);
    if (!headerResult.valid) {
      return headerResult;
    }

    // å¯ç–‘å†…å®¹æ£€æµ‹
    if (this.config.detectMaliciousContent) {
      const malwareResult = await this.detectMaliciousPatterns(file);
      if (!malwareResult.valid) {
        return malwareResult;
      }
    }

    return { valid: true };
  }

  // æ£€æŸ¥æ–‡ä»¶å¤´éƒ¨ç­¾åï¼ˆé­”æœ¯æ•°å­—ï¼‰
  private async checkFileHeader(file: File): Promise<ValidationResult> {
    // å®ç°æ–‡ä»¶å¤´éƒ¨æ£€æŸ¥
    return { valid: true };
  }

  // æ£€æµ‹æ¶æ„å†…å®¹æ¨¡å¼
  private async detectMaliciousPatterns(file: File): Promise<ValidationResult> {
    // å®ç°æ¶æ„å†…å®¹æ£€æµ‹
    return { valid: true };
  }

  // æƒé™éªŒè¯é›†æˆ
  async validatePermissions(file: File, user: UserContext): Promise<ValidationResult> {
    // å¦‚æœé…ç½®äº†æƒé™éªŒè¯æœåŠ¡
    if (this.config.permissionValidator) {
      return await this.config.permissionValidator(file, user);
    }

    return { valid: true };
  }
}
```

### 11. æ€§èƒ½ä¼˜åŒ–

å¢åŠ é¢„åŠ è½½å’Œç½‘ç»œé€‚åº”æ€§ç­–ç•¥ï¼š

```typescript
// ç½‘ç»œæ£€æµ‹å™¨
class NetworkDetector {
  private listeners: Array<(network: NetworkInfo) => void> = [];
  private currentNetwork: NetworkInfo = {
    online: navigator.onLine,
    type: this.getConnectionType(),
    speed: 0,
    rtt: 0,
  };

  constructor() {
    // ç›‘å¬åœ¨çº¿çŠ¶æ€
    window.addEventListener('online', () => this.updateNetworkInfo());
    window.addEventListener('offline', () => this.updateNetworkInfo());

    // å¦‚æœæ”¯æŒNetwork Information API
    if ('connection' in navigator) {
      const connection = (navigator as any).connection;
      connection.addEventListener('change', () => this.updateNetworkInfo());
    }

    // åˆå§‹åŒ–ç½‘ç»œä¿¡æ¯
    this.updateNetworkInfo();

    // å®šæœŸæµ‹é‡ç½‘ç»œé€Ÿåº¦
    setInterval(() => this.measureNetworkSpeed(), 60000);
  }

  getCurrentNetwork(): NetworkInfo {
    return { ...this.currentNetwork };
  }

  onNetworkChange(callback: (network: NetworkInfo) => void): () => void {
    this.listeners.push(callback);

    // è¿”å›å–æ¶ˆè®¢é˜…çš„å‡½æ•°
    return () => {
      this.listeners = this.listeners.filter(cb => cb !== callback);
    };
  }

  private updateNetworkInfo(): void {
    const oldNetwork = { ...this.currentNetwork };

    this.currentNetwork.online = navigator.onLine;
    this.currentNetwork.type = this.getConnectionType();

    if ('connection' in navigator) {
      const connection = (navigator as any).connection;
      this.currentNetwork.rtt = connection.rtt;

      // å¦‚æœæœ‰effectiveTypeå±æ€§ï¼Œæ ¹æ®å®ƒä¼°è®¡é€Ÿåº¦
      if (connection.effectiveType) {
        this.currentNetwork.speed = this.estimateSpeedFromEffectiveType(connection.effectiveType);
      }
    }

    // é€šçŸ¥ç›‘å¬å™¨
    if (JSON.stringify(oldNetwork) !== JSON.stringify(this.currentNetwork)) {
      this.notifyListeners();
    }
  }

  private getConnectionType(): 'wifi' | 'cellular' | 'ethernet' | 'unknown' {
    if (!('connection' in navigator)) return 'unknown';

    const connection = (navigator as any).connection;
    if (!connection.type) return 'unknown';

    switch (connection.type) {
      case 'wifi':
        return 'wifi';
      case 'cellular':
        return 'cellular';
      case 'ethernet':
        return 'ethernet';
      default:
        return 'unknown';
    }
  }

  private estimateSpeedFromEffectiveType(effectiveType: string): number {
    // æ ¹æ®effectiveTypeä¼°è®¡é€Ÿåº¦ (Mbps)
    switch (effectiveType) {
      case 'slow-2g':
        return 0.1;
      case '2g':
        return 0.5;
      case '3g':
        return 2;
      case '4g':
        return 10;
      default:
        return 1;
    }
  }

  private notifyListeners(): void {
    this.listeners.forEach(callback => {
      try {
        callback(this.currentNetwork);
      } catch (err) {
        console.error('ç½‘ç»œçŠ¶æ€ç›‘å¬å›è°ƒé”™è¯¯:', err);
      }
    });
  }

  // æµ‹é‡å®é™…ç½‘ç»œé€Ÿåº¦
  private async measureNetworkSpeed(): Promise<void> {
    if (!navigator.onLine) return;

    try {
      const startTime = performance.now();
      const response = await fetch('/ping', { method: 'GET', cache: 'no-store' });
      const endTime = performance.now();

      if (response.ok) {
        const rtt = endTime - startTime;
        this.currentNetwork.rtt = rtt;

        // æ ¹æ®RTTä¼°ç®—é€Ÿåº¦
        if (rtt < 50) {
          this.currentNetwork.speed = 20; // é«˜é€Ÿè¿æ¥
        } else if (rtt < 100) {
          this.currentNetwork.speed = 10; // è‰¯å¥½è¿æ¥
        } else if (rtt < 200) {
          this.currentNetwork.speed = 5; // ä¸­ç­‰è¿æ¥
        } else if (rtt < 500) {
          this.currentNetwork.speed = 2; // æ…¢é€Ÿè¿æ¥
        } else {
          this.currentNetwork.speed = 0.5; // éå¸¸æ…¢çš„è¿æ¥
        }

        this.notifyListeners();
      }
    } catch (err) {
      // å¿½ç•¥é”™è¯¯ï¼Œä¿æŒå½“å‰é€Ÿåº¦ä¼°è®¡
    }
  }
}

// è‡ªé€‚åº”ä¸Šä¼ æ§åˆ¶å™¨
class AdaptiveUploadController {
  private networkDetector: NetworkDetector;
  private config: AdaptiveConfig;

  private currentChunkSize: number;
  private currentConcurrency: number;

  constructor(networkDetector: NetworkDetector, config: AdaptiveConfig) {
    this.networkDetector = networkDetector;
    this.config = {
      baseChunkSize: 2 * 1024 * 1024, // 2MB
      baseConcurrency: 3,
      minChunkSize: 256 * 1024, // æœ€å°åˆ†ç‰‡å¤§å°256KB
      maxChunkSize: 10 * 1024 * 1024, // æœ€å¤§åˆ†ç‰‡å¤§å°10MB
      minConcurrency: 1,
      maxConcurrency: 6,
      ...config,
    };

    // åˆå§‹åŒ–è®¾ç½®
    const network = networkDetector.getCurrentNetwork();
    this.adjustSettings(network);

    // ç›‘å¬ç½‘ç»œå˜åŒ–
    this.networkDetector.onNetworkChange(network => {
      this.adjustSettings(network);
    });
  }

  // è·å–å½“å‰æœ€ä¼˜è®¾ç½®
  getOptimalSettings(): UploadSettings {
    return {
      chunkSize: this.currentChunkSize,
      concurrency: this.currentConcurrency,
    };
  }

  // æ ¹æ®ç½‘ç»œçŠ¶å†µè°ƒæ•´è®¾ç½®
  private adjustSettings(network: NetworkInfo): void {
    // ç¦»çº¿æƒ…å†µ
    if (!network.online) {
      this.currentChunkSize = this.config.minChunkSize;
      this.currentConcurrency = this.config.minConcurrency;
      return;
    }

    // æ ¹æ®ç½‘é€Ÿè°ƒæ•´åˆ†ç‰‡å¤§å°
    if (network.speed > 10) {
      // é«˜é€Ÿè¿æ¥
      this.currentChunkSize = this.config.maxChunkSize;
    } else if (network.speed > 5) {
      // ä¸­é€Ÿè¿æ¥
      this.currentChunkSize = this.config.baseChunkSize;
    } else if (network.speed > 2) {
      // ä½é€Ÿè¿æ¥
      this.currentChunkSize = this.config.baseChunkSize / 2;
    } else {
      // æä½é€Ÿè¿æ¥
      this.currentChunkSize = this.config.minChunkSize;
    }

    // æ ¹æ®ç½‘ç»œç±»å‹è°ƒæ•´å¹¶å‘æ•°
    if (network.type === 'wifi' || network.type === 'ethernet') {
      this.currentConcurrency = Math.min(Math.ceil(network.speed / 2), this.config.maxConcurrency);
    } else if (network.type === 'cellular') {
      // ç§»åŠ¨ç½‘ç»œé™ä½å¹¶å‘ï¼Œé¿å…è¿‡åº¦æ¶ˆè€—æµé‡
      this.currentConcurrency = Math.min(Math.ceil(network.speed / 3), this.config.maxConcurrency);
    } else {
      this.currentConcurrency = this.config.baseConcurrency;
    }

    // ç¡®ä¿è®¾ç½®åœ¨åˆç†èŒƒå›´å†…
    this.currentChunkSize = Math.max(
      this.config.minChunkSize,
      Math.min(this.currentChunkSize, this.config.maxChunkSize),
    );

    this.currentConcurrency = Math.max(
      this.config.minConcurrency,
      Math.min(this.currentConcurrency, this.config.maxConcurrency),
    );
  }
}
```

### 12. æœ¬åœ°ç¼“å­˜ä¼˜åŒ–è®¾è®¡

å¢å¼ºçš„IndexedDBå­˜å‚¨ç­–ç•¥ï¼š

```typescript
// å¢å¼ºçš„å­˜å‚¨ç®¡ç†å™¨
class StorageManager {
  private dbName: string;
  private storeName: string;
  private db: IDBDatabase | null = null;
  private ready: Promise<void>;

  constructor(options: StorageOptions = {}) {
    this.dbName = options.dbName || 'file-uploader-storage';
    this.storeName = options.storeName || 'uploads';
    this.ready = this.initDB();
  }

  // åˆå§‹åŒ–æ•°æ®åº“
  private async initDB(): Promise<void> {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, 1);

      request.onerror = () => {
        console.error('æ— æ³•æ‰“å¼€IndexedDB');
        reject(new Error('IndexedDBè®¿é—®è¢«æ‹’ç»'));
      };

      request.onsuccess = () => {
        this.db = request.result;
        resolve();
      };

      request.onupgradeneeded = event => {
        const db = request.result;

        // åˆ›å»ºå¯¹è±¡å­˜å‚¨
        if (!db.objectStoreNames.contains(this.storeName)) {
          const store = db.createObjectStore(this.storeName, { keyPath: 'id' });
          store.createIndex('fileId', 'fileId', { unique: false });
          store.createIndex('createdAt', 'createdAt', { unique: false });
        }
      };
    });
  }

  // ä¿å­˜ä¸Šä¼ çŠ¶æ€
  async saveUploadState(fileId: string, state: UploadState): Promise<void> {
    await this.ready;

    return new Promise((resolve, reject) => {
      if (!this.db) {
        reject(new Error('æ•°æ®åº“æœªåˆå§‹åŒ–'));
        return;
      }

      try {
        const transaction = this.db.transaction([this.storeName], 'readwrite');
        const store = transaction.objectStore(this.storeName);

        // å‡†å¤‡æ•°æ®
        const data = {
          id: `state_${fileId}`,
          fileId,
          type: 'state',
          data: state,
          createdAt: Date.now(),
          updatedAt: Date.now(),
        };

        // ä¿å­˜
        const request = store.put(data);

        request.onsuccess = () => resolve();
        request.onerror = () => reject(new Error('ä¿å­˜ä¸Šä¼ çŠ¶æ€å¤±è´¥'));
      } catch (err) {
        reject(err);
      }
    });
  }

  // ä¿å­˜æ–‡ä»¶åˆ†ç‰‡
  async saveChunk(fileId: string, chunkIndex: number, chunk: Blob): Promise<void> {
    await this.ready;

    return new Promise((resolve, reject) => {
      if (!this.db) {
        reject(new Error('æ•°æ®åº“æœªåˆå§‹åŒ–'));
        return;
      }

      try {
        const transaction = this.db.transaction([this.storeName], 'readwrite');
        const store = transaction.objectStore(this.storeName);

        // å‡†å¤‡æ•°æ®
        const data = {
          id: `chunk_${fileId}_${chunkIndex}`,
          fileId,
          type: 'chunk',
          chunkIndex,
          data: chunk,
          size: chunk.size,
          createdAt: Date.now(),
        };

        // ä¿å­˜
        const request = store.put(data);

        request.onsuccess = () => resolve();
        request.onerror = () => reject(new Error('ä¿å­˜åˆ†ç‰‡å¤±è´¥'));
      } catch (err) {
        reject(err);
      }
    });
  }

  // è·å–ä¸Šä¼ çŠ¶æ€
  async getUploadState(fileId: string): Promise<UploadState | null> {
    await this.ready;

    return new Promise((resolve, reject) => {
      if (!this.db) {
        reject(new Error('æ•°æ®åº“æœªåˆå§‹åŒ–'));
        return;
      }

      try {
        const transaction = this.db.transaction([this.storeName], 'readonly');
        const store = transaction.objectStore(this.storeName);

        const request = store.get(`state_${fileId}`);

        request.onsuccess = () => {
          const result = request.result;
          resolve(result ? result.data : null);
        };

        request.onerror = () => reject(new Error('è·å–ä¸Šä¼ çŠ¶æ€å¤±è´¥'));
      } catch (err) {
        reject(err);
      }
    });
  }

  // è·å–æ–‡ä»¶åˆ†ç‰‡
  async getChunk(fileId: string, chunkIndex: number): Promise<Blob | null> {
    await this.ready;

    return new Promise((resolve, reject) => {
      if (!this.db) {
        reject(new Error('æ•°æ®åº“æœªåˆå§‹åŒ–'));
        return;
      }

      try {
        const transaction = this.db.transaction([this.storeName], 'readonly');
        const store = transaction.objectStore(this.storeName);

        const request = store.get(`chunk_${fileId}_${chunkIndex}`);

        request.onsuccess = () => {
          const result = request.result;
          resolve(result ? result.data : null);
        };

        request.onerror = () => reject(new Error('è·å–åˆ†ç‰‡å¤±è´¥'));
      } catch (err) {
        reject(err);
      }
    });
  }

  // è·å–æ–‡ä»¶çš„æ‰€æœ‰åˆ†ç‰‡ç´¢å¼•
  async getChunkIndices(fileId: string): Promise<number[]> {
    await this.ready;

    return new Promise((resolve, reject) => {
      if (!this.db) {
        reject(new Error('æ•°æ®åº“æœªåˆå§‹åŒ–'));
        return;
      }

      try {
        const transaction = this.db.transaction([this.storeName], 'readonly');
        const store = transaction.objectStore(this.storeName);
        const index = store.index('fileId');

        const request = index.getAll(fileId);

        request.onsuccess = () => {
          const results = request.result;
          const chunkIndices = results
            .filter(item => item.type === 'chunk')
            .map(item => item.chunkIndex);

          resolve(chunkIndices);
        };

        request.onerror = () => reject(new Error('è·å–åˆ†ç‰‡ç´¢å¼•å¤±è´¥'));
      } catch (err) {
        reject(err);
      }
    });
  }

  // åˆ é™¤æ–‡ä»¶ç›¸å…³æ•°æ®
  async deleteFile(fileId: string): Promise<void> {
    await this.ready;

    return new Promise((resolve, reject) => {
      if (!this.db) {
        reject(new Error('æ•°æ®åº“æœªåˆå§‹åŒ–'));
        return;
      }

      try {
        const transaction = this.db.transaction([this.storeName], 'readwrite');
        const store = transaction.objectStore(this.storeName);
        const index = store.index('fileId');

        const request = index.getAll(fileId);

        request.onsuccess = () => {
          const results = request.result;

          // åˆ é™¤æ‰€æœ‰ç›¸å…³è®°å½•
          const deleteTransaction = this.db!.transaction([this.storeName], 'readwrite');
          const deleteStore = deleteTransaction.objectStore(this.storeName);

          let deletedCount = 0;

          results.forEach(item => {
            const deleteRequest = deleteStore.delete(item.id);

            deleteRequest.onsuccess = () => {
              deletedCount++;
              if (deletedCount === results.length) {
                resolve();
              }
            };

            deleteRequest.onerror = () => {
              reject(new Error('åˆ é™¤æ–‡ä»¶æ•°æ®å¤±è´¥'));
            };
          });

          // å¦‚æœæ²¡æœ‰è®°å½•ï¼Œç›´æ¥è§£æ
          if (results.length === 0) {
            resolve();
          }
        };

        request.onerror = () => reject(new Error('è·å–æ–‡ä»¶æ•°æ®å¤±è´¥'));
      } catch (err) {
        reject(err);
      }
    });
  }

  // æ¸…ç†è¿‡æœŸæ•°æ®
  async cleanupExpiredData(maxAge: number = 7 * 24 * 60 * 60 * 1000): Promise<void> {
    await this.ready;

    return new Promise((resolve, reject) => {
      if (!this.db) {
        reject(new Error('æ•°æ®åº“æœªåˆå§‹åŒ–'));
        return;
      }

      try {
        const transaction = this.db.transaction([this.storeName], 'readwrite');
        const store = transaction.objectStore(this.storeName);
        const index = store.index('createdAt');

        const now = Date.now();
        const range = IDBKeyRange.upperBound(now - maxAge);

        const request = index.openCursor(range);

        request.onsuccess = event => {
          const cursor = (event.target as IDBRequest).result;

          if (cursor) {
            store.delete(cursor.value.id);
            cursor.continue();
          } else {
            resolve();
          }
        };

        request.onerror = () => reject(new Error('æ¸…ç†è¿‡æœŸæ•°æ®å¤±è´¥'));
      } catch (err) {
        reject(err);
      }
    });
  }

  // è·å–å­˜å‚¨ä½¿ç”¨æƒ…å†µ
  async getStorageUsage(): Promise<StorageUsage> {
    await this.ready;

    return new Promise((resolve, reject) => {
      if (!this.db) {
        reject(new Error('æ•°æ®åº“æœªåˆå§‹åŒ–'));
        return;
      }

      try {
        const transaction = this.db.transaction([this.storeName], 'readonly');
        const store = transaction.objectStore(this.storeName);

        const request = store.getAll();

        request.onsuccess = () => {
          const results = request.result;

          let totalSize = 0;
          let chunkCount = 0;
          let fileCount = 0;
          const fileIds = new Set();

          results.forEach(item => {
            if (item.type === 'chunk') {
              totalSize += item.size || 0;
              chunkCount++;
              fileIds.add(item.fileId);
            }
          });

          fileCount = fileIds.size;

          resolve({
            totalSize,
            chunkCount,
            fileCount,
          });
        };

        request.onerror = () => reject(new Error('è·å–å­˜å‚¨ä½¿ç”¨æƒ…å†µå¤±è´¥'));
      } catch (err) {
        reject(err);
      }
    });
  }
}
```

### 13. ç›‘æ§ä¸åˆ†æ

å¢åŠ ç›‘æ§ä¸åˆ†ææ¨¡å—ï¼š

```typescript
// æ€§èƒ½æŒ‡æ ‡æ”¶é›†å™¨
class MetricsCollector {
  private metrics: {
    uploads: UploadMetric[];
    errors: ErrorMetric[];
    performance: PerformanceMetric[];
  };

  private config: MetricsConfig;

  constructor(config: MetricsConfig = {}) {
    this.metrics = {
      uploads: [],
      errors: [],
      performance: [],
    };

    this.config = {
      maxEntries: 100,
      enabled: true,
      ...config,
    };
  }

  // è®°å½•ä¸Šä¼ æŒ‡æ ‡
  recordUpload(metric: UploadMetric): void {
    if (!this.config.enabled) return;

    this.metrics.uploads.push({
      timestamp: Date.now(),
      ...metric,
    });

    this.truncateMetrics('uploads');
  }

  // è®°å½•é”™è¯¯æŒ‡æ ‡
  recordError(error: Error | UploadError, context: any = {}): void {
    if (!this.config.enabled) return;

    this.metrics.errors.push({
      timestamp: Date.now(),
      error: {
        message: error.message,
        name: error.name,
        code: (error as UploadError).code,
        stack: error.stack,
      },
      context,
    });

    this.truncateMetrics('errors');
  }

  // è®°å½•æ€§èƒ½æŒ‡æ ‡
  recordPerformance(metric: PerformanceMetric): void {
    if (!this.config.enabled) return;

    this.metrics.performance.push({
      timestamp: Date.now(),
      ...metric,
    });

    this.truncateMetrics('performance');
  }

  // è·å–ä¸Šä¼ ç»Ÿè®¡æ•°æ®
  getUploadStats(): UploadStats {
    if (!this.config.enabled) return { success: 0, failed: 0, avgSpeed: 0, avgTime: 0 };

    const uploads = this.metrics.uploads;

    // åŸºæœ¬ç»Ÿè®¡
    const total = uploads.length;
    const success = uploads.filter(m => m.success).length;
    const failed = total - success;

    // é€Ÿåº¦å’Œæ—¶é—´ç»Ÿè®¡
    let totalSpeed = 0;
    let totalTime = 0;
    let successfulUploads = 0;

    uploads.forEach(upload => {
      if (upload.success && upload.speed && upload.duration) {
        totalSpeed += upload.speed;
        totalTime += upload.duration;
        successfulUploads++;
      }
    });

    const avgSpeed = successfulUploads ? totalSpeed / successfulUploads : 0;
    const avgTime = successfulUploads ? totalTime / successfulUploads : 0;

    return {
      total,
      success,
      failed,
      avgSpeed,
      avgTime,
    };
  }

  // è·å–é”™è¯¯æ‘˜è¦
  getErrorSummary(timeWindow: number = 3600000): ErrorReport {
    if (!this.config.enabled) return { count: 0, types: {} };

    const now = Date.now();
    const relevantErrors = this.metrics.errors.filter(e => e.timestamp >= now - timeWindow);

    // åˆ†ç±»é”™è¯¯
    const errorTypes: Record<string, number> = {};

    relevantErrors.forEach(error => {
      const code = error.error.code || 'unknown';
      errorTypes[code] = (errorTypes[code] || 0) + 1;
    });

    return {
      count: relevantErrors.length,
      types: errorTypes,
    };
  }

  // è·å–æ€§èƒ½åˆ†æ
  getPerformanceAnalysis(): PerformanceReport {
    if (!this.config.enabled) {
      return {
        avgHashTime: 0,
        avgChunkTime: 0,
        avgUploadTime: 0,
        bottlenecks: [],
      };
    }

    const metrics = this.metrics.performance;

    // è®¡ç®—å„é˜¶æ®µå¹³å‡æ—¶é—´
    const hashMetrics = metrics.filter(m => m.operation === 'hash');
    const chunkMetrics = metrics.filter(m => m.operation === 'chunk');
    const uploadMetrics = metrics.filter(m => m.operation === 'upload');

    const avgHashTime = this.calculateAverage(hashMetrics, 'duration');
    const avgChunkTime = this.calculateAverage(chunkMetrics, 'duration');
    const avgUploadTime = this.calculateAverage(uploadMetrics, 'duration');

    // ç¡®å®šæ€§èƒ½ç“¶é¢ˆ
    const bottlenecks = this.identifyBottlenecks([
      { name: 'hash', time: avgHashTime },
      { name: 'chunk', time: avgChunkTime },
      { name: 'upload', time: avgUploadTime },
    ]);

    return {
      avgHashTime,
      avgChunkTime,
      avgUploadTime,
      bottlenecks,
    };
  }

  // å¯¼å‡ºæŒ‡æ ‡æ•°æ®
  exportMetrics(): MetricsData {
    return {
      ...this.metrics,
      stats: {
        uploads: this.getUploadStats(),
        errors: this.getErrorSummary(),
        performance: this.getPerformanceAnalysis(),
      },
    };
  }

  // æ¸…é™¤æ‰€æœ‰æŒ‡æ ‡
  clearMetrics(): void {
    this.metrics = {
      uploads: [],
      errors: [],
      performance: [],
    };
  }

  // é™åˆ¶æŒ‡æ ‡æ•°é‡
  private truncateMetrics(type: 'uploads' | 'errors' | 'performance'): void {
    if (this.metrics[type].length > this.config.maxEntries) {
      this.metrics[type] = this.metrics[type].slice(-this.config.maxEntries);
    }
  }

  // è®¡ç®—å¹³å‡å€¼
  private calculateAverage(metrics: any[], field: string): number {
    if (!metrics.length) return 0;

    const sum = metrics.reduce((acc, m) => acc + (m[field] || 0), 0);
    return sum / metrics.length;
  }

  // è¯†åˆ«æ€§èƒ½ç“¶é¢ˆ
  private identifyBottlenecks(operations: { name: string; time: number }[]): string[] {
    // è®¡ç®—æ€»æ—¶é—´
    const totalTime = operations.reduce((sum, op) => sum + op.time, 0);

    // ç“¶é¢ˆé˜ˆå€¼ï¼ˆå æ€»æ—¶é—´çš„40%ä»¥ä¸Šï¼‰
    const threshold = totalTime * 0.4;

    return operations.filter(op => op.time >= threshold).map(op => op.name);
  }
}
```

### 14. å¼€å‘è€…æ¨¡å¼è®¾è®¡

ä¸ºæ–¹ä¾¿å¼€å‘è€…è°ƒè¯•ï¼Œç‰¹åˆ«è®¾è®¡äº†å¼€å‘è€…æ¨¡å¼ï¼Œè¯¥æ¨¡å¼å¯åœ¨é…ç½®ä¸­å¯ç”¨ï¼Œä¼šåœ¨æ§åˆ¶å°è¾“å‡ºæ‰€æœ‰æ ¸å¿ƒåŠŸèƒ½çš„æ—¥å¿—ã€‚

#### å¼€å‘è€…æ¨¡å¼é…ç½®

```typescript
// å¼€å‘è€…æ¨¡å¼é…ç½®æ¥å£
interface DevModeConfig {
  enabled: boolean; // æ˜¯å¦å¯ç”¨å¼€å‘è€…æ¨¡å¼
  logLevel: 'debug' | 'info' | 'warn' | 'error'; // æ—¥å¿—çº§åˆ«
  logFilter?: Array<string>; // æ—¥å¿—ç±»åˆ«è¿‡æ»¤
  logFormat?: 'pretty' | 'json'; // æ—¥å¿—æ ¼å¼
  performanceMonitoring?: boolean; // æ˜¯å¦ç›‘æ§æ€§èƒ½
  networkLogging?: boolean; // æ˜¯å¦è®°å½•ç½‘ç»œè¯·æ±‚
  workerLogging?: boolean; // æ˜¯å¦è®°å½•Workeræ“ä½œ
  pluginTracing?: boolean; // æ˜¯å¦è¿½è¸ªæ’ä»¶è°ƒç”¨é“¾
  etaPredictionDetails?: boolean; // æ˜¯å¦æ˜¾ç¤ºETAé¢„æµ‹è¯¦ç»†ä¿¡æ¯
}

// å¼€å‘è€…æ¨¡å¼é…ç½®ç¤ºä¾‹
const uploader = new FileUploader({
  target: 'https://api.example.com/upload',
  devMode: {
    enabled: true,
    logLevel: 'debug',
    logFilter: ['network', 'worker', 'plugin'],
    logFormat: 'pretty',
    performanceMonitoring: true,
    networkLogging: true,
    etaPredictionDetails: true, // å¯ç”¨ETAé¢„æµ‹è¯¦ç»†ä¿¡æ¯
  },
});

// ç®€åŒ–é…ç½®
const uploader = new FileUploader({
  target: 'https://api.example.com/upload',
  devMode: true, // ä½¿ç”¨é»˜è®¤å¼€å‘è€…æ¨¡å¼é…ç½®
});
```

#### æ—¥å¿—ç³»ç»Ÿè®¾è®¡

```typescript
// å¢å¼ºçš„æ—¥å¿—ç³»ç»Ÿ
class Logger {
  private config: LoggerConfig;
  private prefix: string;
  static instance: Logger | null = null;

  private constructor(config: LoggerConfig = {}, prefix: string = '') {
    this.config = {
      level: 'info',
      format: 'pretty',
      enabled: false,
      ...config,
    };
    this.prefix = prefix;
  }

  // å•ä¾‹æ¨¡å¼è·å–æˆ–åˆ›å»ºLoggerå®ä¾‹
  static getInstance(config?: LoggerConfig, prefix?: string): Logger {
    if (!Logger.instance) {
      Logger.instance = new Logger(config, prefix);
    } else if (config) {
      Logger.instance.updateConfig(config);
      if (prefix) Logger.instance.prefix = prefix;
    }
    return Logger.instance;
  }

  // æ›´æ–°é…ç½®
  updateConfig(config: Partial<LoggerConfig>): void {
    this.config = { ...this.config, ...config };
  }

  // æ—¥å¿—çº§åˆ«æ–¹æ³•
  debug(message: string, data?: any, category?: string): void {
    this.log('debug', message, data, category);
  }

  info(message: string, data?: any, category?: string): void {
    this.log('info', message, data, category);
  }

  warn(message: string, data?: any, category?: string): void {
    this.log('warn', message, data, category);
  }

  error(message: string, data?: any, category?: string): void {
    this.log('error', message, data, category);
  }

  // å†…éƒ¨æ—¥å¿—å¤„ç†æ–¹æ³•
  private log(level: LogLevel, message: string, data?: any, category?: string): void {
    if (!this.config.enabled) return;
    if (!this.isLevelEnabled(level)) return;
    if (category && this.config.filter && !this.config.filter.includes(category)) return;

    const timestamp = new Date().toISOString();
    const prefix = this.prefix ? `[${this.prefix}] ` : '';
    const categoryStr = category ? `[${category}] ` : '';

    if (this.config.format === 'json') {
      const logData = {
        timestamp,
        level,
        message: `${prefix}${categoryStr}${message}`,
        data,
      };
      this.output(level, JSON.stringify(logData));
    } else {
      let formattedMessage = `${timestamp} ${level.toUpperCase()} ${prefix}${categoryStr}${message}`;

      // ç¾åŒ–è¾“å‡º
      if (data) {
        if (typeof data === 'object') {
          try {
            formattedMessage += `\n${JSON.stringify(data, null, 2)}`;
          } catch (e) {
            formattedMessage += `\n[æ— æ³•åºåˆ—åŒ–çš„æ•°æ®]`;
          }
        } else {
          formattedMessage += ` ${data}`;
        }
      }
      this.output(level, formattedMessage);
    }
  }

  // æ£€æŸ¥æ—¥å¿—çº§åˆ«æ˜¯å¦å¯ç”¨
  private isLevelEnabled(level: LogLevel): boolean {
    const levels: LogLevel[] = ['debug', 'info', 'warn', 'error'];
    const configLevelIndex = levels.indexOf(this.config.level);
    const logLevelIndex = levels.indexOf(level);
    return logLevelIndex >= configLevelIndex;
  }

  // è¾“å‡ºæ—¥å¿—
  private output(level: LogLevel, message: string): void {
    switch (level) {
      case 'debug':
        console.debug(message);
        break;
      case 'info':
        console.info(message);
        break;
      case 'warn':
        console.warn(message);
        break;
      case 'error':
        console.error(message);
        break;
    }
  }

  // åˆ›å»ºå­æ—¥å¿—å™¨ï¼Œç»§æ‰¿çˆ¶é…ç½®
  createSubLogger(prefix: string): Logger {
    const subLogger = new Logger(this.config, `${this.prefix}:${prefix}`);
    return subLogger;
  }
}
```

#### å¼€å‘è€…æ¨¡å¼å®ç°

```typescript
// å¼€å‘è€…æ¨¡å¼æ’ä»¶
const devModePlugin = (options: DevModeConfig | boolean = true): Plugin => ({
  name: 'dev-mode',
  version: '1.0.0',
  install: (uploader, opts) => {
    // å¤„ç†å¸ƒå°”å€¼é…ç½®
    const config: DevModeConfig =
      options === true
        ? {
            enabled: true,
            logLevel: 'info',
          }
        : (options as DevModeConfig);

    // åˆå§‹åŒ–æ—¥å¿—ç³»ç»Ÿ
    const logger = Logger.getInstance({
      level: config.logLevel,
      format: config.logFormat || 'pretty',
      enabled: config.enabled,
      filter: config.logFilter,
    });

    // æ³¨å…¥æ—¥å¿—è®°å½•å™¨
    uploader.logger = logger;

    // ç›‘å¬ä¸Šä¼ äº‹ä»¶
    uploader.on('upload:start', file => {
      logger.info(
        `å¼€å§‹ä¸Šä¼ æ–‡ä»¶: ${file.name}`,
        {
          fileSize: file.size,
          fileType: file.type,
        },
        'core',
      );
    });

    uploader.on('upload:progress', progress => {
      logger.debug(`ä¸Šä¼ è¿›åº¦: ${progress}%`, null, 'core');
    });

    uploader.on('upload:success', result => {
      logger.info(`ä¸Šä¼ æˆåŠŸ: ${result.url}`, result, 'core');
    });

    uploader.on('upload:error', error => {
      logger.error(`ä¸Šä¼ å¤±è´¥: ${error.message}`, error, 'core');
    });

    // ç›‘å¬ç½‘ç»œè¯·æ±‚ï¼ˆå¦‚æœå¯ç”¨ï¼‰
    if (config.networkLogging) {
      uploader.on('network:request', request => {
        logger.debug(`å‘é€è¯·æ±‚: ${request.method} ${request.url}`, request, 'network');
      });

      uploader.on('network:response', response => {
        logger.debug(`æ¥æ”¶å“åº”: ${response.status}`, response, 'network');
      });

      uploader.on('network:error', error => {
        logger.error(`ç½‘ç»œé”™è¯¯: ${error.message}`, error, 'network');
      });
    }

    // ç›‘å¬Workeræ“ä½œï¼ˆå¦‚æœå¯ç”¨ï¼‰
    if (config.workerLogging) {
      uploader.on('worker:task', task => {
        logger.debug(`Workerä»»åŠ¡: ${task.type}`, task, 'worker');
      });

      uploader.on('worker:result', result => {
        logger.debug(`Workerç»“æœ`, result, 'worker');
      });
    }

    // ç›‘å¬æ’ä»¶è°ƒç”¨é“¾ï¼ˆå¦‚æœå¯ç”¨ï¼‰
    if (config.pluginTracing) {
      uploader.on('plugin:before', (hookName, plugin) => {
        logger.debug(`æ‰§è¡Œæ’ä»¶é’©å­: ${plugin.name}.${hookName} (å¼€å§‹)`, null, 'plugin');
      });

      uploader.on('plugin:after', (hookName, plugin, duration) => {
        logger.debug(
          `æ‰§è¡Œæ’ä»¶é’©å­: ${plugin.name}.${hookName} (å®Œæˆ)`,
          { duration: `${duration}ms` },
          'plugin',
        );
      });
    }

    // æ€§èƒ½ç›‘æ§ï¼ˆå¦‚æœå¯ç”¨ï¼‰
    if (config.performanceMonitoring) {
      const metricsCollector = new MetricsCollector({ enabled: true });

      uploader.on('upload:start', () => {
        performance.mark('upload-start');
      });

      uploader.on('upload:end', () => {
        performance.mark('upload-end');
        const measure = performance.measure('upload-duration', 'upload-start', 'upload-end');
        metricsCollector.recordPerformance({
          operation: 'upload',
          duration: measure.duration,
        });

        logger.info(
          `ä¸Šä¼ æ€§èƒ½æŒ‡æ ‡`,
          {
            duration: `${Math.round(measure.duration)}ms`,
          },
          'performance',
        );
      });
    }
  },
});
```

#### å¼€å‘è€…æ¨¡å¼ä½¿ç”¨ç¤ºä¾‹

```typescript
// åŸºæœ¬ç”¨æ³•
import { FileUploader } from '@file-chunk-uploader/core';
import { devMode } from '@file-chunk-uploader/utils';

const uploader = new FileUploader({
  target: 'https://api.example.com/upload',
});

// å¯ç”¨å¼€å‘è€…æ¨¡å¼ï¼ˆå¸¦è‡ªå®šä¹‰é…ç½®ï¼‰
uploader.use(
  devMode({
    enabled: true,
    logLevel: 'debug',
    logFilter: ['network', 'core'],
    performanceMonitoring: true,
  }),
);

// æˆ–è€…é€šè¿‡é…ç½®é€‰é¡¹ç›´æ¥å¯ç”¨
const uploader = new FileUploader({
  target: 'https://api.example.com/upload',
  devMode: true, // ä½¿ç”¨é»˜è®¤å¼€å‘è€…æ¨¡å¼é…ç½®
});
```

å¼€å‘è€…æ¨¡å¼ä¸»è¦åŠŸèƒ½åŒ…æ‹¬ï¼š

1. **è¯¦ç»†æ—¥å¿—è¾“å‡º**ï¼šåœ¨æ§åˆ¶å°è¾“å‡ºæ‰€æœ‰æ ¸å¿ƒåŠŸèƒ½çš„è¿è¡Œæ—¥å¿—
2. **å¤šçº§åˆ«æ—¥å¿—**ï¼šæ”¯æŒdebugã€infoã€warnã€errorå››ç§æ—¥å¿—çº§åˆ«
3. **åˆ†ç±»è¿‡æ»¤**ï¼šå¯æŒ‰åŠŸèƒ½æ¨¡å—è¿‡æ»¤æ—¥å¿—è¾“å‡º
4. **ç½‘ç»œè¯·æ±‚æ—¥å¿—**ï¼šè®°å½•æ‰€æœ‰ä¸Šä¼ ç›¸å…³çš„ç½‘ç»œè¯·æ±‚å’Œå“åº”
5. **æ€§èƒ½ç›‘æ§**ï¼šæµ‹é‡å’Œè®°å½•å…³é”®æ“ä½œçš„æ‰§è¡Œæ—¶é—´
6. **æ’ä»¶è°ƒç”¨é“¾è·Ÿè¸ª**ï¼šç›‘æ§æ’ä»¶ç”Ÿå‘½å‘¨æœŸé’©å­çš„æ‰§è¡Œè¿‡ç¨‹
7. **è‡ªå®šä¹‰æ ¼å¼åŒ–**ï¼šæ”¯æŒJSONæ ¼å¼æˆ–ç¾åŒ–æ ¼å¼çš„æ—¥å¿—è¾“å‡º

å¼€å‘è€…æ¨¡å¼çš„è®¾è®¡ç›®æ ‡æ˜¯ä¸ºå¼€å‘è€…æä¾›å®Œæ•´çš„è°ƒè¯•å·¥å…·é“¾ï¼ŒåŒæ—¶ä¿è¯åœ¨ç”Ÿäº§ç¯å¢ƒä¸­ä¸ä¼šå½±å“æ€§èƒ½å’Œç”¨æˆ·ä½“éªŒã€‚

### 15. åŒ…å¤§å°ä¼˜åŒ–ç­–ç•¥

é€šè¿‡å¾®åŒ…æ¶æ„å’Œæ’ä»¶ç³»ç»Ÿï¼Œå®ç°"æŒ‰éœ€åŠ è½½"ï¼Œç”¨æˆ·å¯ä»¥åªå®‰è£…å’Œå¼•å…¥éœ€è¦çš„åŠŸèƒ½ï¼š

```typescript
// æœ€å°åŒ–å¼•å…¥ (~3KB gzipped)
import { FileUploader } from '@file-chunk-uploader/core';
import { fetchAdapter } from '@file-chunk-uploader/network/fetch-adapter';

const uploader = new FileUploader({
  target: 'https://api.example.com/upload',
  networkAdapter: fetchAdapter(),
});

// æ ‡å‡†åŠŸèƒ½å¼•å…¥ (~10KB gzipped)
import { FileUploader } from '@file-chunk-uploader/standard';

// å®Œæ•´åŠŸèƒ½å¼•å…¥ (~25KB gzipped)
import { FileUploader } from '@file-chunk-uploader/full';
```

å…¥å£åŒ…å®šä¹‰:

```typescript
// @file-chunk-uploader/standard/src/index.ts
import { FileUploader } from '@file-chunk-uploader/core';
import { chunkUpload } from '@file-chunk-uploader/chunk';
import { resumable } from '@file-chunk-uploader/resume';
import { fetchAdapter } from '@file-chunk-uploader/network';
import { errorHandler } from '@file-chunk-uploader/errors';

// é¢„é…ç½®æ ‡å‡†åŠŸèƒ½
export class StandardUploader extends FileUploader {
  constructor(options = {}) {
    super(options);

    // è‡ªåŠ¨åŠ è½½æ ¸å¿ƒæ’ä»¶
    this.use(fetchAdapter());
    this.use(chunkUpload({ chunkSize: options.chunkSize || 2 * 1024 * 1024 }));
    this.use(resumable({ enabled: options.resumable !== false }));
    this.use(errorHandler({ retryCount: options.retryCount || 3 }));
  }
}

export { FileUploader };
export default StandardUploader;
```

## æŠ€æœ¯é€‰æ‹©

- **æ ¸å¿ƒ**: TypeScript
- **æ„å»ºå·¥å…·**:
  - esbuild (å¼€å‘ç¯å¢ƒ - æ›´å¿«çš„æ„å»ºé€Ÿåº¦)
  - Rollup (ç”Ÿäº§ç¯å¢ƒ - æ›´å¥½çš„tree-shakingæ”¯æŒ)
- **æµ‹è¯•æ¡†æ¶**: Jest
- **ä»£ç è´¨é‡**: ESLint + Prettier
- **æ–‡æ¡£**: TypeDoc + Storybook
- **åŒ…ç®¡ç†**: PNPM (æ›´å¥½çš„Monorepoæ”¯æŒ)
- **Monorepoç®¡ç†**: Turborepo (æ›¿ä»£Lernaï¼Œæä¾›æ›´å¥½çš„ç¼“å­˜æœºåˆ¶)

## æ¡†æ¶é€‚é…åŒ…æ˜ç¡®æ”¯æŒç‰ˆæœ¬

| æ¡†æ¶    | æœ€ä½æ”¯æŒç‰ˆæœ¬ | ç‰¹æ€§æ”¯æŒ                | æœåŠ¡ç«¯æ¸²æŸ“       |
| ------- | ------------ | ----------------------- | ---------------- |
| React   | React 16.8+  | Hooks, Context, SSR     | âœ… å®Œå…¨æ”¯æŒ      |
| Vue     | Vue 3.0+     | Composables, Components | âœ… æ”¯æŒNuxt 3    |
| Angular | Angular 13+  | Services, Directives    | âœ… æ”¯æŒUniversal |
| Svelte  | Svelte 3+    | Stores, Components      | âœ… åŸºæœ¬æ”¯æŒ      |

## æ¡†æ¶ç‰¹æ€§å¯¹æ¯”

| ç‰¹æ€§           | åŸç”ŸJS | React | Vue | Angular | Svelte |
| -------------- | ------ | ----- | --- | ------- | ------ |
| æ–‡ä»¶é€‰æ‹©ç»„ä»¶   | âœ…     | âœ…    | âœ…  | âœ…      | âœ…     |
| æ‹–æ”¾åŒºåŸŸ       | âœ…     | âœ…    | âœ…  | âœ…      | âœ…     |
| è¿›åº¦UI         | âœ…     | âœ…    | âœ…  | âœ…      | âœ…     |
| çŠ¶æ€ç®¡ç†é›†æˆ   | -      | âœ…    | âœ…  | âœ…      | âœ…     |
| æœåŠ¡ç«¯ç»„ä»¶æ”¯æŒ | -      | âœ…    | âœ…  | âœ…      | âœ…     |
| æŒ‡ä»¤æ”¯æŒ       | -      | -     | âœ…  | âœ…      | -      |
| TypeScriptæ”¯æŒ | âœ…     | âœ…    | âœ…  | âœ…      | âœ…     |
| è‡ªå®šä¹‰é’©å­     | âœ…     | âœ…    | âœ…  | âœ…      | âœ…     |
| Observableæ”¯æŒ | âœ…     | âœ…    | âœ…  | âœ…      | âœ…     |
| SSRå®‰å…¨        | -      | âœ…    | âœ…  | âœ…      | âœ…     |

## CI/CDæµç¨‹è®¾è®¡

```
github-workflow/
â”œâ”€â”€ ci.yml                     # æŒç»­é›†æˆå·¥ä½œæµ
â”‚   â”œâ”€â”€ ä»£ç æ£€æŸ¥ (lint + type-check)
â”‚   â”œâ”€â”€ å•å…ƒæµ‹è¯• (jest)
â”‚   â”œâ”€â”€ é›†æˆæµ‹è¯•
â”‚   â””â”€â”€ æ‰“åŒ…éªŒè¯
â”‚
â”œâ”€â”€ release.yml                # å‘å¸ƒå·¥ä½œæµ
â”‚   â”œâ”€â”€ ç‰ˆæœ¬æ£€æŸ¥
â”‚   â”œâ”€â”€ å˜æ›´æ—¥å¿—ç”Ÿæˆ
â”‚   â”œâ”€â”€ æ„å»º
â”‚   â”œâ”€â”€ æµ‹è¯•
â”‚   â””â”€â”€ å‘å¸ƒåˆ°NPM
â”‚
â””â”€â”€ docs.yml                   # æ–‡æ¡£éƒ¨ç½²å·¥ä½œæµ
    â”œâ”€â”€ æ„å»ºæ–‡æ¡£
    â”œâ”€â”€ æ„å»ºç¤ºä¾‹åº”ç”¨
    â””â”€â”€ éƒ¨ç½²åˆ°GitHub Pages
```

## äº§å“è·¯çº¿å›¾

1. v1.0: åŸºç¡€åŠŸèƒ½ - åˆ†ç‰‡ä¸Šä¼ ã€æ–­ç‚¹ç»­ä¼ ã€æ ¸å¿ƒæ¨¡å—
2. v1.1: æ¡†æ¶é€‚é… - å‘å¸ƒReactã€Vueã€åŸç”ŸJSé€‚é…å™¨
3. v1.2: Workerå¢å¼º - å®Œæ•´Workeræ± ã€å¹¶è¡Œå¤„ç†ä¼˜åŒ–
4. v1.3: æ€§èƒ½ä¼˜åŒ– - æ™ºèƒ½è°ƒåº¦ã€å†…å­˜ç®¡ç†ä¼˜åŒ–ã€ç½‘ç»œè‡ªé€‚åº”
5. v1.4: å®‰å…¨å¼ºåŒ– - åŠ å¯†ä¼ è¾“ã€å®Œæ•´æ€§æ ¡éªŒã€å†…å®¹æ‰«æ
6. v1.5: ç›‘æ§ä¸åˆ†æ - æ€§èƒ½æŒ‡æ ‡ã€é”™è¯¯èšåˆã€ä½¿ç”¨åˆ†æ
7. v2.0: é«˜çº§ç‰¹æ€§ - å¢å¼ºçš„æ’ä»¶ç³»ç»Ÿã€è‡ªå®šä¹‰å­˜å‚¨é€‚é…å™¨

## æ€»ç»“

è¿™ä¸ªä¼˜åŒ–åçš„è®¾è®¡æ–¹æ¡ˆèåˆäº†ç°ä»£å‰ç«¯å·¥ç¨‹æœ€ä½³å®è·µï¼Œå¹¶é’ˆå¯¹å¤§æ–‡ä»¶ä¸Šä¼ åœºæ™¯è¿›è¡Œäº†å…¨é¢å¢å¼ºã€‚é€šè¿‡å¤šæ¡†æ¶é€‚é…è®¾è®¡å’ŒWeb Workerå¢å¼ºï¼Œæ—¢ä¿è¯äº†æ˜“ç”¨æ€§å’Œå¹¿æ³›çš„å…¼å®¹æ€§ï¼Œåˆå…·å¤‡äº†é«˜æ€§èƒ½ã€é«˜æ‰©å±•æ€§å’Œå¥å£®æ€§ã€‚æ ¸å¿ƒç‰¹ç‚¹åŒ…æ‹¬ï¼š

1. **æ¨¡å—åŒ–è®¾è®¡**: æ¸…æ™°çš„è´£ä»»åˆ†ç¦»å’Œé«˜å†…èšä½è€¦åˆ
2. **å¤šæ¡†æ¶æ”¯æŒ**: åŸç”ŸJSã€Reactã€Vueç­‰æ¡†æ¶çš„æ— ç¼é›†æˆä¸SSRæ”¯æŒ
3. **é«˜æ€§èƒ½å¤„ç†**: Web Workerå¹¶è¡Œè®¡ç®—ã€ç½‘ç»œè‡ªé€‚åº”ç­–ç•¥å’Œä¼˜åŒ–çš„æ•°æ®ä¼ è¾“
4. **å¯æ‰©å±•æ€§**: å¢å¼ºçš„æ’ä»¶ç³»ç»Ÿå’Œç”Ÿå‘½å‘¨æœŸç®¡ç†
5. **å®‰å…¨å¯é **: å…¨é¢çš„é”™è¯¯å¤„ç†ã€æ¢å¤æœºåˆ¶å’Œå®‰å…¨æ£€éªŒ
6. **è½»é‡ä¸ä¼˜åŒ–**: åˆ†å±‚æ‰“åŒ…ç­–ç•¥ç¡®ä¿æœ€å°åŒ–åŒ…ä½“ç§¯
7. **å¼€å‘è€…å‹å¥½**: å…¨é¢çš„ç›‘æ§ä¸åˆ†æèƒ½åŠ›ï¼Œæ”¯æŒObservable API

è¿™ä¸€è®¾è®¡ä¸ä»…æ»¡è¶³äº†å½“å‰éœ€æ±‚ï¼Œè¿˜ä¸ºæœªæ¥çš„åŠŸèƒ½æ‰©å±•å’Œæ€§èƒ½ä¼˜åŒ–æä¾›äº†åšå®åŸºç¡€ï¼ŒåŒæ—¶è€ƒè™‘äº†ç”¨æˆ·ä½“éªŒã€å¼€å‘è€…ä½“éªŒå’Œé•¿æœŸå¯ç»´æŠ¤æ€§çš„å¹³è¡¡ã€‚

## é¡¹ç›®åˆå§‹åŒ–

é¡¹ç›®é‡‡ç”¨æ’ä»¶åŒ–å¾®åŒ…æ¶æ„ï¼Œä½¿ç”¨pnpmä½œä¸ºåŒ…ç®¡ç†å·¥å…·ï¼ŒTurborepoè¿›è¡Œå·¥ä½œæµç®¡ç†ã€‚æ¯ä¸ªåŠŸèƒ½æ¨¡å—éƒ½æ˜¯ç‹¬ç«‹çš„å¾®åŒ…ï¼Œå¯ä»¥å•ç‹¬å‘å¸ƒå’Œä½¿ç”¨ï¼Œé€šè¿‡æ’ä»¶ç³»ç»Ÿç»„åˆåŠŸèƒ½ã€‚

### æŠ€æœ¯æ ˆé€‰æ‹©

- **åŒ…ç®¡ç†**: pnpm
- **Monorepoç®¡ç†**: Turborepo
- **æ„å»ºå·¥å…·**: Rollup (ç”Ÿäº§ç¯å¢ƒ)ï¼ŒVite (å¼€å‘ç¯å¢ƒ)
- **è¯­è¨€**: TypeScript
- **æµ‹è¯•**: Jest
- **ä»£ç è´¨é‡**: ESLint + Prettier
- **ç‰ˆæœ¬ç®¡ç†**: Changesets
- **CI/CD**: GitHub Actions

### ç›®å½•ç»“æ„

```
file-chunk-uploader/
â”œâ”€â”€ packages/                # æ‰€æœ‰å¾®åŒ…
â”‚   â”œâ”€â”€ core/                # æ ¸å¿ƒæœ€å°åŠŸèƒ½
â”‚   â”œâ”€â”€ chunk/               # åˆ†ç‰‡ä¸Šä¼ åŠŸèƒ½
â”‚   â”œâ”€â”€ resume/              # æ–­ç‚¹ç»­ä¼ åŠŸèƒ½
â”‚   â”œâ”€â”€ fast/                # ç§’ä¼ åŠŸèƒ½
â”‚   â”œâ”€â”€ network/             # ç½‘ç»œè¯·æ±‚åŠŸèƒ½
â”‚   â”œâ”€â”€ security/            # å®‰å…¨åŠŸèƒ½
â”‚   â”œâ”€â”€ utils/               # å·¥å…·å‡½æ•°
â”‚   â”œâ”€â”€ errors/              # é”™è¯¯å¤„ç†
â”‚   â”œâ”€â”€ monitoring/          # ç›‘æ§åˆ†æ
â”‚   â”œâ”€â”€ workers/             # WorkeråŠŸèƒ½
â”‚   â”œâ”€â”€ standard/            # æ ‡å‡†åŠŸèƒ½é›†æˆ
â”‚   â”œâ”€â”€ full/                # å®Œæ•´åŠŸèƒ½é›†æˆ
â”‚   â”œâ”€â”€ react/               # Reacté€‚é…å™¨
â”‚   â”œâ”€â”€ vue/                 # Vueé€‚é…å™¨
â”‚   â””â”€â”€ vanilla/             # åŸç”ŸJSé€‚é…å™¨
â”œâ”€â”€ examples/                # ç¤ºä¾‹åº”ç”¨
â”‚   â”œâ”€â”€ vanilla/             # åŸç”ŸJSç¤ºä¾‹
â”‚   â”œâ”€â”€ react/               # Reactç¤ºä¾‹
â”‚   â””â”€â”€ vue/                 # Vueç¤ºä¾‹
â”œâ”€â”€ workers/                 # Workerè„šæœ¬
â”œâ”€â”€ docs/                    # æ–‡æ¡£
â”œâ”€â”€ scripts/                 # æ„å»ºå’Œå¼€å‘è„šæœ¬
â””â”€â”€ .github/                 # GitHubé…ç½®
```

### å¼€å‘æµç¨‹

1. **å®‰è£…ä¾èµ–**: `pnpm install`
2. **å¼€å‘æ¨¡å¼**: `pnpm dev`
3. **æ„å»º**: `pnpm build`
4. **æµ‹è¯•**: `pnpm test`
5. **ä»£ç æ£€æŸ¥**: `pnpm lint`
6. **å‘å¸ƒæµç¨‹**:
   - åˆ›å»ºå˜æ›´é›†: `pnpm changeset`
   - æ›´æ–°ç‰ˆæœ¬: `pnpm version-packages`
   - å‘å¸ƒ: `pnpm release`

### åŒ…ä¾èµ–å…³ç³»

æ’ä»¶åŒ–å¾®åŒ…æ¶æ„ä¸­çš„ä¾èµ–å…³ç³»æ›´åŠ æ¸…æ™°ï¼š

```
core (åŸºç¡€ä¸Šä¼ å™¨)
  â†‘
  â”œâ”€â”€ chunk (ä¾èµ–core)
  â”œâ”€â”€ resume (ä¾èµ–core)
  â”œâ”€â”€ network (ä¾èµ–core)
  â”œâ”€â”€ security (ä¾èµ–core)
  â””â”€â”€ errors (ä¾èµ–core)
      â†‘
      â”œâ”€â”€ standard (ä¾èµ–å¤šä¸ªåŸºç¡€åŠŸèƒ½åŒ…)
      â””â”€â”€ full (ä¾èµ–æ‰€æœ‰åŠŸèƒ½åŒ…)
          â†‘
          â”œâ”€â”€ react (ä¾èµ–standardæˆ–core)
          â”œâ”€â”€ vue (ä¾èµ–standardæˆ–core)
          â””â”€â”€ vanilla (ä¾èµ–standardæˆ–core)
```

æ¯ä¸ªåŒ…éƒ½æ˜¯å¯é€‰çš„ï¼Œç”¨æˆ·å¯ä»¥æ ¹æ®éœ€æ±‚è‡ªç”±ç»„åˆã€‚

## æ€»ç»“

è¿™ä¸ªä¼˜åŒ–åçš„è®¾è®¡æ–¹æ¡ˆèåˆäº†ç°ä»£å‰ç«¯å·¥ç¨‹æœ€ä½³å®è·µï¼Œå¹¶é’ˆå¯¹å¤§æ–‡ä»¶ä¸Šä¼ åœºæ™¯è¿›è¡Œäº†å…¨é¢å¢å¼ºã€‚é€šè¿‡å¤šæ¡†æ¶é€‚é…è®¾è®¡å’ŒWeb Workerå¢å¼ºï¼Œæ—¢ä¿è¯äº†æ˜“ç”¨æ€§å’Œå¹¿æ³›çš„å…¼å®¹æ€§ï¼Œåˆå…·å¤‡äº†é«˜æ€§èƒ½ã€é«˜æ‰©å±•æ€§å’Œå¥å£®æ€§ã€‚æ ¸å¿ƒç‰¹ç‚¹åŒ…æ‹¬ï¼š

1. **æ¨¡å—åŒ–è®¾è®¡**: æ¸…æ™°çš„è´£ä»»åˆ†ç¦»å’Œé«˜å†…èšä½è€¦åˆ
2. **å¤šæ¡†æ¶æ”¯æŒ**: åŸç”ŸJSã€Reactã€Vueç­‰æ¡†æ¶çš„æ— ç¼é›†æˆä¸SSRæ”¯æŒ
3. **é«˜æ€§èƒ½å¤„ç†**: Web Workerå¹¶è¡Œè®¡ç®—ã€ç½‘ç»œè‡ªé€‚åº”ç­–ç•¥å’Œä¼˜åŒ–çš„æ•°æ®ä¼ è¾“
4. **å¯æ‰©å±•æ€§**: å¢å¼ºçš„æ’ä»¶ç³»ç»Ÿå’Œç”Ÿå‘½å‘¨æœŸç®¡ç†
5. **å®‰å…¨å¯é **: å…¨é¢çš„é”™è¯¯å¤„ç†ã€æ¢å¤æœºåˆ¶å’Œå®‰å…¨æ£€éªŒ
6. **è½»é‡ä¸ä¼˜åŒ–**: åˆ†å±‚æ‰“åŒ…ç­–ç•¥ç¡®ä¿æœ€å°åŒ–åŒ…ä½“ç§¯
7. **å¼€å‘è€…å‹å¥½**: å…¨é¢çš„ç›‘æ§ä¸åˆ†æèƒ½åŠ›ï¼Œæ”¯æŒObservable API

è¿™ä¸€è®¾è®¡ä¸ä»…æ»¡è¶³äº†å½“å‰éœ€æ±‚ï¼Œè¿˜ä¸ºæœªæ¥çš„åŠŸèƒ½æ‰©å±•å’Œæ€§èƒ½ä¼˜åŒ–æä¾›äº†åšå®åŸºç¡€ï¼ŒåŒæ—¶è€ƒè™‘äº†ç”¨æˆ·ä½“éªŒã€å¼€å‘è€…ä½“éªŒå’Œé•¿æœŸå¯ç»´æŠ¤æ€§çš„å¹³è¡¡ã€‚

## 16. å¢å¼ºçš„é‡è¯•æœºåˆ¶

ä¸ºäº†æé«˜ä¸Šä¼ çš„å¯é æ€§å’Œç”¨æˆ·ä½“éªŒï¼Œæˆ‘ä»¬å¯¹é‡è¯•æœºåˆ¶è¿›è¡Œäº†å…¨é¢å¢å¼ºï¼Œä¸»è¦åŒ…æ‹¬ä»¥ä¸‹ä¸‰ä¸ªæ–¹é¢ï¼š

### 16.1 é‡è¯•äº‹ä»¶é€šçŸ¥

é‡è¯•äº‹ä»¶é€šçŸ¥ç³»ç»Ÿå…è®¸ç”¨æˆ·ç•Œé¢å®æ—¶å±•ç¤ºé‡è¯•çŠ¶æ€ï¼Œæå‡ç”¨æˆ·ä½“éªŒï¼š

```typescript
// é‡è¯•ç›¸å…³äº‹ä»¶ç±»å‹å®šä¹‰
interface RetryStartInfo {
  fileId: string;
  chunkIndex?: number;
  retryCount: number;
  delay: number;
  error: UploadError;
}

interface RetrySuccessInfo {
  fileId: string;
  chunkIndex?: number;
  successCount: number;
}

interface RetryFailedInfo {
  fileId: string;
  error: UploadError;
  recoverable: boolean;
}

// äº‹ä»¶ç›‘å¬ç¤ºä¾‹
uploader.on('retry:start', (info: RetryStartInfo) => {
  console.log(`å¼€å§‹ç¬¬${info.retryCount}æ¬¡é‡è¯•ï¼Œå°†åœ¨${info.delay / 1000}ç§’åæ‰§è¡Œ`);
  // æ›´æ–°UIï¼Œæ˜¾ç¤ºé‡è¯•å€’è®¡æ—¶
  showRetryCountdown(info.fileId, info.delay);
});

uploader.on('retry:success', (info: RetrySuccessInfo) => {
  console.log(`é‡è¯•æˆåŠŸï¼æ–‡ä»¶${info.fileId}å·²æˆåŠŸé‡è¯•${info.successCount}æ¬¡`);
  // æ›´æ–°UIï¼Œæ˜¾ç¤ºé‡è¯•æˆåŠŸ
  updateUploadStatus(info.fileId, 'retry-success');
});

uploader.on('retry:failed', (info: RetryFailedInfo) => {
  console.log(`é‡è¯•å¤±è´¥ï¼š${info.error.message}`);
  // æ›´æ–°UIï¼Œæ˜¾ç¤ºé‡è¯•å¤±è´¥
  if (info.recoverable) {
    showRetryButton(info.fileId);
  } else {
    showFailureMessage(info.fileId, info.error.message);
  }
});
```

è¿™äº›äº‹ä»¶ä¹Ÿè¢«é›†æˆåˆ°æ’ä»¶ç³»ç»Ÿä¸­ï¼Œå…è®¸æ’ä»¶å“åº”é‡è¯•ç”Ÿå‘½å‘¨æœŸï¼š

```typescript
// æ’ä»¶ç”Ÿå‘½å‘¨æœŸé’©å­ä¸­çš„é‡è¯•äº‹ä»¶
interface PluginLifecycle {
  // ... å…¶ä»–ç”Ÿå‘½å‘¨æœŸé’©å­
  onRetryStart?: (retryInfo: RetryStartInfo) => void | Promise<void>;
  onRetrySuccess?: (retryInfo: RetrySuccessInfo) => void | Promise<void>;
  onRetryFailed?: (retryInfo: RetryFailedInfo) => void | Promise<void>;
}
```

### 16.2 é‡è¯•çŠ¶æ€æŒä¹…åŒ–

é‡è¯•çŠ¶æ€æŒä¹…åŒ–ç¡®ä¿é¡µé¢åˆ·æ–°æˆ–ä¼šè¯ä¸­æ–­åä»èƒ½ä¿æŒæ­£ç¡®çš„é‡è¯•è®¡æ•°å’Œç­–ç•¥ï¼š

```typescript
// StorageManageræ‰©å±•
interface StorageManager {
  // ... ç°æœ‰æ–¹æ³•
  saveRetryState(fileId: string, state: RetryState): Promise<void>;
  getRetryState(fileId: string): Promise<RetryState | null>;
  getActiveUploads(): Promise<string[]>;
}

// é‡è¯•çŠ¶æ€ç»“æ„
interface RetryState {
  fileId: string;
  retryCount: number;
  lastRetryTime: number;
  chunkRetries: Record<number, number>; // æ¯ä¸ªåˆ†ç‰‡çš„é‡è¯•æ¬¡æ•°
  successfulRetries: number;
  failedRetries: number;
}
```

é‡è¯•çŠ¶æ€æŒä¹…åŒ–çš„ä¸»è¦ä¼˜åŠ¿ï¼š

1. **ä¼šè¯æ¢å¤**: æµè§ˆå™¨åˆ·æ–°æˆ–å…³é—­åé‡æ–°æ‰“å¼€ï¼Œèƒ½å¤Ÿæ¢å¤æ­£ç¡®çš„é‡è¯•è®¡æ•°
2. **é¿å…é‡è¯•å¾ªç¯**: é˜²æ­¢å› åˆ·æ–°é¡µé¢å¯¼è‡´é‡è¯•è®¡æ•°é‡ç½®ï¼Œé€ æˆæ— é™é‡è¯•
3. **æ™ºèƒ½å†³ç­–æ”¯æŒ**: ä¸ºåŸºäºå†å²æˆåŠŸç‡çš„æ™ºèƒ½å†³ç­–æä¾›æ•°æ®åŸºç¡€
4. **å¤šè®¾å¤‡åŒæ­¥**: ç”¨æˆ·åœ¨ä¸åŒè®¾å¤‡ç»§ç»­ä¸Šä¼ æ—¶ï¼Œä¿æŒä¸€è‡´çš„é‡è¯•çŠ¶æ€

#### å®ç°ç¤ºä¾‹

```typescript
// åœ¨StorageManagerä¸­å®ç°é‡è¯•çŠ¶æ€å­˜å‚¨
class StorageManager {
  // ... ç°æœ‰ä»£ç 

  // ä¿å­˜é‡è¯•çŠ¶æ€
  async saveRetryState(fileId: string, state: RetryState): Promise<void> {
    await this.ready;

    return new Promise((resolve, reject) => {
      if (!this.db) {
        reject(new Error('æ•°æ®åº“æœªåˆå§‹åŒ–'));
        return;
      }

      try {
        const transaction = this.db.transaction([this.storeName], 'readwrite');
        const store = transaction.objectStore(this.storeName);

        // å‡†å¤‡æ•°æ®
        const data = {
          id: `retry_${fileId}`,
          fileId,
          type: 'retry',
          data: state,
          createdAt: Date.now(),
          updatedAt: Date.now(),
        };

        // ä¿å­˜
        const request = store.put(data);

        request.onsuccess = () => resolve();
        request.onerror = () => reject(new Error('ä¿å­˜é‡è¯•çŠ¶æ€å¤±è´¥'));
      } catch (err) {
        reject(err);
      }
    });
  }

  // è·å–é‡è¯•çŠ¶æ€
  async getRetryState(fileId: string): Promise<RetryState | null> {
    await this.ready;

    return new Promise((resolve, reject) => {
      if (!this.db) {
        reject(new Error('æ•°æ®åº“æœªåˆå§‹åŒ–'));
        return;
      }

      try {
        const transaction = this.db.transaction([this.storeName], 'readonly');
        const store = transaction.objectStore(this.storeName);

        const request = store.get(`retry_${fileId}`);

        request.onsuccess = () => {
          const result = request.result;
          resolve(result ? result.data : null);
        };

        request.onerror = () => reject(new Error('è·å–é‡è¯•çŠ¶æ€å¤±è´¥'));
      } catch (err) {
        reject(err);
      }
    });
  }
}
```

### 16.3 æ™ºèƒ½é‡è¯•å†³ç­–

æ™ºèƒ½é‡è¯•å†³ç­–æœºåˆ¶æ ¹æ®å†å²æˆåŠŸç‡å’Œç½‘ç»œçŠ¶å†µåŠ¨æ€è°ƒæ•´é‡è¯•ç­–ç•¥ï¼š

```typescript
// é‡è¯•ç»Ÿè®¡æ•°æ®ç»“æ„
interface RetryStats {
  successCount: number;
  failCount: number;
  lastRetryTime: number;
  networkConditions: NetworkConditionRecord[];
}

interface NetworkConditionRecord {
  time: number;
  online: boolean;
  type: 'wifi' | 'cellular' | 'ethernet' | 'unknown';
  speed: number; // Mbps
  rtt: number;   // ms
}

// æ™ºèƒ½å†³ç­–å®ç°
private shouldRetry(context: ErrorContext): boolean {
  const fileId = context.fileId;
  if (!fileId) return true; // é»˜è®¤é‡è¯•

  const stats = this.retryHistory.get(fileId);
  if (!stats) return true;

  // 1. åŸºäºå†å²æˆåŠŸç‡å†³ç­–
  const totalAttempts = stats.successCount + stats.failCount;
  if (totalAttempts > 5 && stats.successCount / totalAttempts < 0.2) {
    return false; // æˆåŠŸç‡ä½äº20%ï¼Œä¸å†é‡è¯•
  }

  // 2. åŸºäºç½‘ç»œè´¨é‡å†³ç­–
  const recentConditions = stats.networkConditions.slice(-3);
  if (recentConditions.length >= 3) {
    // è¿ç»­3æ¬¡ç½‘ç»œçŠ¶å†µå¾ˆå·®ï¼Œæš‚åœé‡è¯•
    const allPoorConditions = recentConditions.every(c =>
      !c.online || c.speed < 0.5 || c.rtt > 1000
    );

    if (allPoorConditions) {
      return false;
    }
  }

  // 3. åŸºäºé”™è¯¯ç±»å‹å†³ç­–
  if (context.lastError && isServerRejectionError(context.lastError)) {
    // æœåŠ¡å™¨æ˜ç¡®æ‹’ç»çš„é”™è¯¯ï¼Œå‡å°‘é‡è¯•æ¬¡æ•°
    return context.retryCount < Math.min(2, this.config.maxRetries);
  }

  return true;
}
```

æ™ºèƒ½é‡è¯•å†³ç­–çš„ä¸»è¦ä¼˜åŠ¿ï¼š

1. **æé«˜æˆåŠŸç‡**: é¿å…åœ¨ä¸å¤ªå¯èƒ½æˆåŠŸçš„æƒ…å†µä¸‹æµªè´¹èµ„æºè¿›è¡Œé‡è¯•
2. **ä¼˜åŒ–ç”¨æˆ·ä½“éªŒ**: åœ¨ç½‘ç»œæ¡ä»¶æå·®æ—¶é¿å…é¢‘ç¹é‡è¯•å¯¼è‡´çš„ç•Œé¢å¡é¡¿
3. **å‡è½»æœåŠ¡å™¨è´Ÿæ‹…**: æ™ºèƒ½è°ƒæ•´é‡è¯•ç­–ç•¥ï¼Œé¿å…æ— æ•ˆè¯·æ±‚å¢åŠ æœåŠ¡å™¨è´Ÿè½½
4. **è‡ªé€‚åº”è°ƒæ•´**: æ ¹æ®ä¸åŒæ–‡ä»¶çš„ä¸Šä¼ æƒ…å†µåŠ¨æ€è°ƒæ•´é‡è¯•ç­–ç•¥

### 16.4 é‡è¯•æœºåˆ¶é…ç½®é€‰é¡¹

ä¸ºäº†æä¾›æ›´ç»†ç²’åº¦çš„æ§åˆ¶ï¼Œé‡è¯•æœºåˆ¶æ”¯æŒä¸°å¯Œçš„é…ç½®é€‰é¡¹ï¼š

```typescript
interface RetryConfig {
  // åŸºæœ¬é…ç½®
  enabled: boolean; // æ˜¯å¦å¯ç”¨é‡è¯•
  maxRetries: number; // æœ€å¤§é‡è¯•æ¬¡æ•°
  maxRetriesPerChunk?: number; // æ¯ä¸ªåˆ†ç‰‡æœ€å¤§é‡è¯•æ¬¡æ•°

  // å»¶è¿Ÿç­–ç•¥
  baseDelay: number; // åŸºç¡€å»¶è¿Ÿï¼ˆæ¯«ç§’ï¼‰
  maxDelay: number; // æœ€å¤§å»¶è¿Ÿï¼ˆæ¯«ç§’ï¼‰
  useExponentialBackoff: boolean; // æ˜¯å¦ä½¿ç”¨æŒ‡æ•°é€€é¿

  // æ™ºèƒ½å†³ç­–é…ç½®
  useSmartDecision: boolean; // æ˜¯å¦å¯ç”¨æ™ºèƒ½å†³ç­–
  minSuccessRate: number; // æœ€ä½æˆåŠŸç‡é˜ˆå€¼
  networkQualityThreshold: {
    // ç½‘ç»œè´¨é‡é˜ˆå€¼
    minSpeed: number; // æœ€ä½é€Ÿåº¦ (Mbps)
    maxRtt: number; // æœ€å¤§RTT (ms)
  };

  // é”™è¯¯ç±»å‹ç‰¹å®šé…ç½®
  errorTypeRetries: {
    // ç‰¹å®šé”™è¯¯ç±»å‹çš„æœ€å¤§é‡è¯•æ¬¡æ•°
    network: number; // ç½‘ç»œé”™è¯¯
    server: number; // æœåŠ¡å™¨é”™è¯¯
    timeout: number; // è¶…æ—¶é”™è¯¯
    unknown: number; // æœªçŸ¥é”™è¯¯
  };

  // æŒä¹…åŒ–é…ç½®
  persistRetryState: boolean; // æ˜¯å¦æŒä¹…åŒ–é‡è¯•çŠ¶æ€

  // äº‹ä»¶é€šçŸ¥é…ç½®
  notifyOnRetry: boolean; // æ˜¯å¦å‘é€é‡è¯•äº‹ä»¶é€šçŸ¥
}

// é»˜è®¤é…ç½®
const defaultRetryConfig: RetryConfig = {
  enabled: true,
  maxRetries: 3,
  baseDelay: 1000,
  maxDelay: 30000,
  useExponentialBackoff: true,
  useSmartDecision: true,
  minSuccessRate: 0.2,
  networkQualityThreshold: {
    minSpeed: 0.5,
    maxRtt: 1000,
  },
  errorTypeRetries: {
    network: 5,
    server: 2,
    timeout: 3,
    unknown: 1,
  },
  persistRetryState: true,
  notifyOnRetry: true,
};
```

è¿™äº›å¢å¼ºçš„é‡è¯•æœºåˆ¶å…±åŒä½œç”¨ï¼Œå¤§å¹…æé«˜äº†å¤§æ–‡ä»¶ä¸Šä¼ åœ¨ä¸ç¨³å®šç½‘ç»œç¯å¢ƒä¸‹çš„å¯é æ€§å’Œç”¨æˆ·ä½“éªŒã€‚

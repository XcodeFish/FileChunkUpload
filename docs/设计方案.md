# 大文件上传npm依赖包架构设计方案（优化版）

## 项目概述

名称：file-chunk-uploader
定位：一个轻量级、高性能、易用的大文件上传解决方案，支持多框架环境

## 核心架构设计

### 1. 模块化设计

采用插件化微包架构进行精细化的包管理：

```text
file-chunk-uploader/
├── packages/
│   ├── core/                    # 上传器核心（最小实现）
│   │   ├── src/
│   │   │   ├── uploader.ts      # 上传器基础类
│   │   │   ├── plugin-manager.ts # 插件管理器
│   │   │   └── index.ts
│   │
│   ├── chunk/                   # 文件分片功能包
│   │   ├── src/
│   │   │   ├── file-handler.ts  # 文件处理与切片
│   │   │   ├── chunk-strategy.ts # 分片上传策略
│   │   │   └── index.ts
│   │
│   ├── resume/                  # 断点续传功能包
│   │   ├── src/
│   │   │   ├── resume-strategy.ts # 断点续传策略
│   │   │   ├── storage.ts       # 上传进度存储
│   │   │   └── index.ts
│   │
│   ├── fast/                    # 秒传功能包
│   │   ├── src/
│   │   │   ├── fast-strategy.ts # 秒传策略
│   │   │   ├── hash.ts          # 文件哈希计算
│   │   │   └── index.ts
│   │
│   ├── network/                 # 网络请求功能包
│   │   ├── src/
│   │   │   ├── adapters/
│   │   │   │   ├── xhr-adapter.ts   # XHR适配器
│   │   │   │   ├── fetch-adapter.ts # Fetch适配器
│   │   │   │   └── index.ts
│   │   │   ├── detector.ts         # 网络检测
│   │   │   ├── adaptive.ts         # 自适应策略
│   │   │   └── index.ts
│   │
│   ├── security/                # 安全功能包
│   │   ├── src/
│   │   │   ├── validator.ts      # 文件验证
│   │   │   ├── encryption.ts     # 加密处理
│   │   │   ├── content-scanner.ts # 文件内容扫描
│   │   │   └── index.ts
│   │
│   ├── utils/                   # 通用工具包
│   │   ├── src/
│   │   │   ├── throttle.ts       # 节流控制
│   │   │   ├── logger.ts         # 日志工具
│   │   │   ├── observable.ts     # Observable支持
│   │   │   └── index.ts
│   │
│   ├── errors/                  # 错误处理包
│   │   ├── src/
│   │   │   ├── error-types.ts    # 错误类型定义
│   │   │   ├── error-handler.ts  # 错误处理器
│   │   │   ├── recovery.ts       # 错误恢复机制
│   │   │   └── index.ts
│   │
│   ├── monitoring/              # 监控与分析包
│   │   ├── src/
│   │   │   ├── metrics.ts        # 性能指标收集
│   │   │   ├── reporter.ts       # 数据上报
│   │   │   └── index.ts
│   │
│   ├── workers/                 # Web Worker功能包
│   │   ├── src/
│   │   │   ├── worker-pool.ts    # Worker池管理
│   │   │   ├── file-worker.ts    # 文件处理Worker
│   │   │   └── index.ts
│   │   ├── dist/
│   │   │   └── workers/          # 构建后的Worker脚本
│   │
│   ├── standard/                # 标准功能整合包
│   │   ├── src/
│   │   │   └── index.ts          # 导出标准功能集
│   │
│   ├── full/                    # 完整功能整合包
│   │   ├── src/
│   │   │   └── index.ts          # 导出所有功能
│   │
│   ├── react/                   # React适配器
│   ├── vue/                     # Vue适配器
│   └── vanilla/                 # 原生JS适配器
```

### 2. 核心API设计

#### 插件化API设计

```typescript
// 基本使用示例 - 插件化API
import { FileUploader } from '@file-chunk-uploader/core';
import { chunkUpload } from '@file-chunk-uploader/chunk';
import { resumable } from '@file-chunk-uploader/resume';
import { networkAdaptive } from '@file-chunk-uploader/network';

// 创建上传器实例
const uploader = new FileUploader({
  target: 'https://api.example.com/upload',
});

// 使用插件扩展功能
uploader.use(chunkUpload({ chunkSize: 2 * 1024 * 1024 }));
uploader.use(resumable({ storage: 'indexedDB' }));
uploader.use(networkAdaptive());

// 其他API保持一致
uploader
  .upload(fileObject)
  .then(result => console.log('上传完成', result))
  .catch(error => console.error('上传失败', error));

// 控制方法
uploader.pause();
uploader.resume();
uploader.cancel();
```

#### 整合包API（简化使用）

```typescript
// 使用整合包简化配置
import { FileUploader } from '@file-chunk-uploader/standard';

const uploader = new FileUploader({
  target: 'https://api.example.com/upload',
  chunkSize: 2 * 1024 * 1024,
  concurrency: 3,
  retryCount: 3,
  checksum: true,
  resumable: true,
  onProgress: progress => console.log(`上传进度: ${progress}%`),
});

// 同样支持Promise和Observable API
uploader.upload(fileObject).then(result => console.log('上传完成', result));

// 响应式API
uploader.uploadObservable(fileObject).subscribe({
  next: progress => console.log(`上传进度: ${progress}%`),
  complete: () => console.log('上传完成'),
});
```

### 3. 插件系统设计

每个插件都是一个独立的功能模块，遵循统一的接口：

```typescript
// 插件接口
interface Plugin {
  name: string;
  version: string;
  install: (uploader: FileUploaderCore, options?: any) => void;
  hooks?: Record<string, Function>;
  cleanup?: () => void;
}

// 插件示例
const chunkUploadPlugin = (options = {}): Plugin => ({
  name: 'chunk-upload',
  version: '1.0.0',
  install: (uploader, opts) => {
    const finalOptions = { ...options, ...opts };
    // 向上传器注入分片上传功能
    uploader.strategies.set('chunk', new ChunkUploadStrategy(finalOptions));
    // 注册钩子
    uploader.registerHook('beforeUpload', async file => {
      // 处理文件
      return file;
    });
  },
  hooks: {
    // 各生命周期钩子
    beforeUpload: file => {
      /* ... */
    },
    afterChunkUpload: (chunk, index) => {
      /* ... */
    },
  },
  cleanup: () => {
    // 清理资源
  },
});
```

### 4. 依赖注入与适配器模式

保持原有适配器模式设计，通过插件系统注入适配器：

```typescript
// 网络适配器
import { FileUploader } from '@file-chunk-uploader/core';
import { networkPlugin } from '@file-chunk-uploader/network';
import { createFetchAdapter } from '@file-chunk-uploader/network/adapters';

const uploader = new FileUploader();
uploader.use(
  networkPlugin({
    adapter: createFetchAdapter(), // 使用Fetch适配器
  }),
);

// 也可以使用XHR适配器
import { createXhrAdapter } from '@file-chunk-uploader/network/adapters';
uploader.use(
  networkPlugin({
    adapter: createXhrAdapter(),
  }),
);

// 或自定义适配器
uploader.use(
  networkPlugin({
    adapter: {
      post: async (url, data, config) => {
        // 自定义实现
        return { success: true };
      },
      get: async (url, config) => {
        // 自定义实现
        return { data: [] };
      },
    },
  }),
);
```

### 5. 工作流程设计

与原设计保持一致。

### 6. 多框架适配设计

增加SSR支持说明：

```typescript
// React适配器增加SSR支持
// @file-chunk-uploader/react

import { useState, useEffect, useRef } from 'react';
import { FileUploaderCore } from '@file-chunk-uploader/core';

// SSR安全的React Hook
export function useFileUploader(config) {
  const [progress, setProgress] = useState(0);
  const [status, setStatus] = useState('idle');
  const [error, setError] = useState(null);
  const uploaderRef = useRef(null);

  useEffect(() => {
    // 仅在客户端环境创建上传器实例
    if (typeof window !== 'undefined') {
      const uploader = new FileUploaderCore({
        ...config,
        onProgress: p => {
          setProgress(p);
          config?.onProgress?.(p);
        },
        onStatusChange: s => {
          setStatus(s);
          config?.onStatusChange?.(s);
        },
        onError: e => {
          setError(e);
          config?.onError?.(e);
        },
      });

      uploaderRef.current = uploader;

      return () => {
        uploader.cancel();
      };
    }
  }, []);

  // SSR安全的API调用
  const upload = file => {
    if (uploaderRef.current) {
      return uploaderRef.current.upload(file);
    }
    return Promise.reject(new Error('上传器未初始化或在服务器端环境'));
  };

  // 其他方法类似实现...

  return {
    uploader: uploaderRef.current,
    progress,
    status,
    error,
    upload,
    pause: () => uploaderRef.current?.pause(),
    resume: () => uploaderRef.current?.resume(),
    cancel: () => uploaderRef.current?.cancel(),
  };
}
```

### 7. Web Worker增强设计

增加懒加载和降级策略：

```typescript
// Web Worker池优化实现
class FileProcessingWorkerPool {
  workers: Worker[] = [];
  taskQueue: Task[] = [];
  activeWorkers: Map<Worker, Task> = new Map();
  isSupported: boolean;
  isInitialized: boolean = false;

  constructor(options = { poolSize: navigator.hardwareConcurrency || 4, lazyInit: true }) {
    // 检测浏览器是否支持Web Worker
    this.isSupported = typeof Worker !== 'undefined';

    // 如果不支持Worker，不创建worker池
    if (!this.isSupported) {
      console.warn('Web Workers不受支持，将使用主线程处理');
      return;
    }

    // 懒加载模式，仅在需要时初始化workers
    if (!options.lazyInit) {
      this.initialize(options.poolSize);
    }
  }

  // 懒加载初始化
  private initialize(poolSize: number): void {
    if (this.isInitialized || !this.isSupported) return;

    for (let i = 0; i < poolSize; i++) {
      try {
        const worker = new Worker(new URL('../workers/file-worker.ts', import.meta.url), {
          type: 'module',
        });

        worker.onmessage = e => this.handleWorkerResult(worker, e.data);
        this.workers.push(worker);
      } catch (err) {
        console.error('创建Worker失败:', err);
        this.isSupported = false;
        break;
      }
    }

    this.isInitialized = this.workers.length > 0;

    // 如果初始化成功，处理队列中待处理的任务
    if (this.isInitialized && this.taskQueue.length > 0) {
      this.processQueue();
    }
  }

  // 处理队列中的任务
  private processQueue(): void {
    while (this.taskQueue.length > 0 && this.getIdleWorker()) {
      const task = this.taskQueue.shift();
      if (task) {
        const worker = this.getIdleWorker();
        if (worker) {
          this.assignTaskToWorker(worker, task);
        }
      }
    }
  }

  // 获取空闲worker
  private getIdleWorker(): Worker | null {
    return this.workers.find(w => !this.activeWorkers.has(w)) || null;
  }

  // 调度任务（支持Worker降级）
  private scheduleTask(task: Task): Promise<any> {
    return new Promise((resolve, reject) => {
      // 任务添加结果回调
      task.resolve = resolve;
      task.reject = reject;

      // 如果Web Worker不受支持或初始化失败，在主线程上执行
      if (!this.isSupported) {
        this.executeOnMainThread(task);
        return;
      }

      // 懒加载初始化
      if (!this.isInitialized) {
        this.initialize(navigator.hardwareConcurrency || 4);
      }

      // 尝试找空闲worker
      const idleWorker = this.getIdleWorker();

      if (idleWorker) {
        this.assignTaskToWorker(idleWorker, task);
      } else {
        // 没有空闲worker，加入队列
        this.taskQueue.push(task);

        // 内存管理：检查队列长度，避免内存溢出
        if (this.taskQueue.length > 100) {
          // 设置合理的上限
          const oldestTask = this.taskQueue.shift();
          oldestTask?.reject(new Error('任务队列溢出，任务被取消'));
        }
      }
    });
  }

  // 主线程上执行任务（降级策略）
  private async executeOnMainThread(task: Task): Promise<void> {
    try {
      let result;

      switch (task.type) {
        case 'hash':
          result = await this.calculateHashInMainThread(task.payload.file, task.payload.algorithm);
          break;

        case 'chunk':
          result = await this.createChunksInMainThread(task.payload.file, task.payload.chunkSize);
          break;

        // 实现其他任务类型的主线程处理...

        default:
          throw new Error(`未知任务类型: ${task.type}`);
      }

      task.resolve(result);
    } catch (err) {
      task.reject(err);
    }
  }

  // 主线程计算哈希实现（降级）
  private async calculateHashInMainThread(file: File, algorithm: string): Promise<string> {
    // 流式读取大文件，避免内存问题
    const chunkSize = 2 * 1024 * 1024; // 2MB块
    const crypto = window.crypto.subtle;
    let hashContext;

    try {
      hashContext = await crypto.digest(algorithm, new ArrayBuffer(0));
    } catch (e) {
      // 降级到简单哈希算法
      return this.calculateSimpleHash(file);
    }

    // 流式处理实现...
    return 'hash-placeholder';
  }

  // 简单哈希算法（最终降级）
  private calculateSimpleHash(file: File): string {
    return `${file.name}-${file.size}-${file.lastModified}`;
  }

  // 主线程分片实现（降级）
  private async createChunksInMainThread(file: File, chunkSize: number): Promise<Blob[]> {
    // 避免一次性创建所有分片导致内存问题
    const totalChunks = Math.ceil(file.size / chunkSize);
    const chunkRefs = [];

    for (let i = 0; i < totalChunks; i++) {
      const start = i * chunkSize;
      const end = Math.min(start + chunkSize, file.size);
      chunkRefs.push({ start, end });
    }

    return chunkRefs.map(ref => file.slice(ref.start, ref.end));
  }

  // 其他方法保持不变...
}
```

### 8. 错误处理系统

增强的错误恢复机制：

```typescript
// 增强的错误处理器
class ErrorHandler {
  private config: ErrorHandlerConfig;
  private metricsCollector: MetricsCollector;

  constructor(config: ErrorHandlerConfig, metricsCollector: MetricsCollector) {
    this.config = config;
    this.metricsCollector = metricsCollector;
  }

  handle(error: UploadError, context: ErrorContext): ErrorAction {
    // 记录错误指标
    this.metricsCollector.recordError(error, context);

    // 实现智能错误恢复策略
    if (error.retryable && context.retryCount < this.config.maxRetries) {
      const retryDelay = this.calculateRetryDelay(context.retryCount);

      return {
        type: 'retry',
        delay: retryDelay,
        message: `将在${retryDelay / 1000}秒后重试（${context.retryCount + 1}/${
          this.config.maxRetries
        }）`,
      };
    }

    // 特定错误类型的恢复策略
    switch (error.code) {
      case 'network_disconnect':
        return {
          type: 'wait_for_connection',
          message: '等待网络连接恢复...',
        };

      case 'server_overload':
        return {
          type: 'retry',
          delay: 30000, // 30秒特殊延迟
          message: '服务器繁忙，将在30秒后重试',
        };

      case 'quota_exceeded':
        return {
          type: 'fail',
          recoverable: false,
          message: '存储配额已满，无法继续上传',
        };

      case 'invalid_chunk_size':
        return {
          type: 'adjust_and_retry',
          newChunkSize: Math.floor(context.chunkSize / 2),
          message: '分片大小调整后重试',
        };

      default:
        return {
          type: 'fail',
          recoverable: error.retryable,
          message: error.message,
        };
    }
  }

  // 实现指数退避算法
  private calculateRetryDelay(retryCount: number): number {
    const baseDelay = 1000; // 1秒
    const maxDelay = 30000; // 30秒
    const jitter = Math.random() * 1000; // 0-1000ms随机抖动

    const exponentialDelay = baseDelay * Math.pow(2, retryCount);
    return Math.min(exponentialDelay + jitter, maxDelay);
  }

  // 错误聚合与报告
  aggregateErrors(timeWindow: number = 60000): ErrorReport {
    return this.metricsCollector.getErrorSummary(timeWindow);
  }
}

// 错误恢复管理器
class ErrorRecoveryManager {
  private errorHandler: ErrorHandler;
  private networkDetector: NetworkDetector;
  private recoveryQueue: Map<string, RecoveryTask> = new Map();
  private storageManager: StorageManager;
  private retryHistory: Map<string, RetryStats> = new Map();
  private eventEmitter: EventEmitter;

  constructor(
    errorHandler: ErrorHandler,
    networkDetector: NetworkDetector,
    storageManager: StorageManager,
    eventEmitter: EventEmitter,
  ) {
    this.errorHandler = errorHandler;
    this.networkDetector = networkDetector;
    this.storageManager = storageManager;
    this.eventEmitter = eventEmitter;

    // 监听网络状态变化
    this.networkDetector.onNetworkChange(network => {
      if (network.online) {
        this.processRecoveryQueue();
      }
    });

    // 初始化时从存储中恢复重试状态
    this.loadRetryStates();
  }

  // 处理错误并安排恢复
  async handleError(error: UploadError, context: ErrorContext): Promise<void> {
    const action = this.errorHandler.handle(error, context);

    // 更新错误统计，用于智能决策
    this.updateErrorStats(error, context);

    switch (action.type) {
      case 'retry':
        // 发送重试开始事件
        this.eventEmitter.emit('retry:start', {
          fileId: context.fileId,
          chunkIndex: context.chunkIndex,
          retryCount: context.retryCount,
          delay: action.delay,
          error,
        });

        await this.scheduleRetry(context, action.delay);
        break;

      case 'wait_for_connection':
        this.eventEmitter.emit('retry:waiting', {
          fileId: context.fileId,
          reason: 'network_disconnect',
        });

        this.queueForNetworkRecovery(context);
        break;

      case 'adjust_and_retry':
        this.eventEmitter.emit('retry:adjusting', {
          fileId: context.fileId,
          chunkIndex: context.chunkIndex,
          oldChunkSize: context.chunkSize,
          newChunkSize: action.newChunkSize,
        });

        await this.adjustAndRetry(context, action);
        break;

      case 'fail':
        // 发送重试失败事件
        this.eventEmitter.emit('retry:failed', {
          fileId: context.fileId,
          error,
          recoverable: action.recoverable,
        });

        this.handleFailure(context, action, error);
        break;
    }

    // 持久化重试状态
    await this.saveRetryState(context);
  }

  // 保存重试状态到持久化存储
  private async saveRetryState(context: ErrorContext): Promise<void> {
    if (!context.fileId) return;

    const retryState = {
      fileId: context.fileId,
      retryCount: context.retryCount,
      lastRetryTime: Date.now(),
      chunkRetries: context.chunkRetries || {},
      successfulRetries: context.successfulRetries || 0,
      failedRetries: context.failedRetries || 0,
    };

    try {
      await this.storageManager.saveRetryState(context.fileId, retryState);
    } catch (err) {
      console.warn('保存重试状态失败', err);
    }
  }

  // 从持久化存储加载重试状态
  private async loadRetryStates(): Promise<void> {
    try {
      const activeUploads = await this.storageManager.getActiveUploads();

      for (const fileId of activeUploads) {
        const retryState = await this.storageManager.getRetryState(fileId);
        if (retryState) {
          this.retryHistory.set(fileId, {
            successCount: retryState.successfulRetries || 0,
            failCount: retryState.failedRetries || 0,
            lastRetryTime: retryState.lastRetryTime,
            networkConditions: [],
          });
        }
      }
    } catch (err) {
      console.warn('加载重试状态失败', err);
    }
  }

  // 更新错误统计信息
  private updateErrorStats(error: UploadError, context: ErrorContext): void {
    const fileId = context.fileId;
    if (!fileId) return;

    let stats = this.retryHistory.get(fileId);
    if (!stats) {
      stats = {
        successCount: 0,
        failCount: 0,
        lastRetryTime: 0,
        networkConditions: [],
      };
      this.retryHistory.set(fileId, stats);
    }

    // 记录当前网络状况
    const networkInfo = this.networkDetector.getCurrentNetwork();
    stats.networkConditions.push({
      time: Date.now(),
      online: networkInfo.online,
      type: networkInfo.type,
      speed: networkInfo.speed,
      rtt: networkInfo.rtt,
    });

    // 保留最近10条记录
    if (stats.networkConditions.length > 10) {
      stats.networkConditions.shift();
    }
  }

  // 智能决策是否值得重试
  private shouldRetry(context: ErrorContext): boolean {
    const fileId = context.fileId;
    if (!fileId) return true; // 默认重试

    const stats = this.retryHistory.get(fileId);
    if (!stats) return true;

    // 1. 如果成功率过低，可能不值得重试
    const totalAttempts = stats.successCount + stats.failCount;
    if (totalAttempts > 5 && stats.successCount / totalAttempts < 0.2) {
      return false; // 成功率低于20%，不再重试
    }

    // 2. 基于网络质量决定是否重试
    const recentConditions = stats.networkConditions.slice(-3); // 最近3次网络状况
    if (recentConditions.length >= 3) {
      // 如果连续3次网络状况很差，暂停重试
      const allPoorConditions = recentConditions.every(
        c => !c.online || c.speed < 0.5 || c.rtt > 1000,
      );

      if (allPoorConditions) {
        return false;
      }
    }

    return true;
  }

  // 重试成功处理
  async handleRetrySuccess(context: ErrorContext): Promise<void> {
    const fileId = context.fileId;
    if (!fileId) return;

    // 更新统计
    const stats = this.retryHistory.get(fileId) || {
      successCount: 0,
      failCount: 0,
      lastRetryTime: 0,
      networkConditions: [],
    };

    stats.successCount++;
    this.retryHistory.set(fileId, stats);

    // 更新持久化存储
    const retryState = (await this.storageManager.getRetryState(fileId)) || {
      fileId,
      retryCount: 0,
      lastRetryTime: Date.now(),
      chunkRetries: {},
      successfulRetries: 0,
      failedRetries: 0,
    };

    retryState.successfulRetries++;
    await this.storageManager.saveRetryState(fileId, retryState);

    // 发送重试成功事件
    this.eventEmitter.emit('retry:success', {
      fileId,
      chunkIndex: context.chunkIndex,
      successCount: stats.successCount,
    });
  }

  // 更多恢复方法实现...
}
```

### 9. 插件系统

增强的插件生命周期管理：

```typescript
// 增强的插件系统
interface PluginLifecycle {
  init?: (uploader: FileUploaderCore) => void | Promise<void>;
  beforeUpload?: (file: File, config: UploadConfig) => File | Promise<File>;
  beforeChunkUpload?: (chunk: Blob, index: number, total: number) => Blob | Promise<Blob>;
  afterChunkUpload?: (response: any, chunk: Blob, index: number) => void | Promise<void>;
  afterUpload?: (result: UploadResult) => void | Promise<void>;
  onError?: (error: UploadError) => boolean | Promise<boolean>; // 返回true表示错误已处理
  onPause?: () => void | Promise<void>;
  onResume?: () => void | Promise<void>;
  onCancel?: () => void | Promise<void>;
  onProgress?: (progress: number) => void | Promise<void>;
  onRetryStart?: (retryInfo: RetryStartInfo) => void | Promise<void>; // 重试开始事件
  onRetrySuccess?: (retryInfo: RetrySuccessInfo) => void | Promise<void>; // 重试成功事件
  onRetryFailed?: (retryInfo: RetryFailedInfo) => void | Promise<void>; // 重试失败事件
  cleanup?: () => void | Promise<void>;
}

class PluginManager {
  private plugins: Map<string, Plugin> = new Map();
  private uploader: FileUploaderCore;
  private lifecycleOrder: Record<keyof PluginLifecycle, 'sequential' | 'parallel'> = {
    init: 'sequential',
    beforeUpload: 'sequential',
    beforeChunkUpload: 'sequential',
    afterChunkUpload: 'parallel',
    afterUpload: 'parallel',
    onError: 'sequential',
    onPause: 'parallel',
    onResume: 'parallel',
    onCancel: 'parallel',
    onProgress: 'parallel',
    onRetryStart: 'parallel',
    onRetrySuccess: 'parallel',
    onRetryFailed: 'parallel',
    cleanup: 'sequential',
  };

  constructor(uploader: FileUploaderCore) {
    this.uploader = uploader;
  }

  register(plugin: Plugin): void {
    if (this.plugins.has(plugin.name)) {
      throw new Error(`插件 "${plugin.name}" 已注册`);
    }

    this.plugins.set(plugin.name, plugin);

    // 如果插件有初始化方法，立即执行
    if (plugin.lifecycle?.init) {
      plugin.lifecycle.init(this.uploader);
    }
  }

  unregister(pluginName: string): boolean {
    const plugin = this.plugins.get(pluginName);
    if (!plugin) return false;

    // 执行插件清理
    if (plugin.lifecycle?.cleanup) {
      plugin.lifecycle.cleanup();
    }

    return this.plugins.delete(pluginName);
  }

  // 调用指定生命周期钩子
  async invokeHook<T>(
    hookName: keyof PluginLifecycle,
    initialValue: T,
    ...args: any[]
  ): Promise<T> {
    const plugins = Array.from(this.plugins.values());
    const executionMode = this.lifecycleOrder[hookName];

    if (executionMode === 'sequential') {
      // 顺序执行
      let result = initialValue;
      for (const plugin of plugins) {
        const hook = plugin.lifecycle?.[hookName] as Function;
        if (hook) {
          result = await hook.call(plugin, result, ...args);
        }
      }
      return result;
    } else {
      // 并行执行
      await Promise.all(
        plugins.map(plugin => {
          const hook = plugin.lifecycle?.[hookName] as Function;
          return hook?.call(plugin, ...args);
        }),
      );
      return initialValue;
    }
  }

  // 实现插件API版本兼容性检查
  checkCompatibility(plugin: Plugin): boolean {
    const requiredVersion = plugin.apiVersion || '1.0.0';
    const currentVersion = this.uploader.apiVersion;

    // 实现语义化版本比较
    return this.isVersionCompatible(currentVersion, requiredVersion);
  }

  private isVersionCompatible(current: string, required: string): boolean {
    // 语义化版本比较实现
    return true; // 简化实现
  }
}
```

### 10. 安全设计

增强的安全模块：

```typescript
// 增强的安全模块
class SecurityManager {
  private config: SecurityConfig;

  constructor(config: SecurityConfig) {
    this.config = {
      maxFileSize: 1024 * 1024 * 1024, // 1GB
      allowedMimeTypes: ['*/*'],
      disallowedMimeTypes: [],
      scanFileContent: false,
      validateHash: false,
      ...config,
    };
  }

  // 全面的文件验证
  async validateFile(file: File): Promise<ValidationResult> {
    // 基本验证
    if (!file) {
      return { valid: false, reason: 'file_missing' };
    }

    // 文件大小验证
    if (file.size > this.config.maxFileSize) {
      return {
        valid: false,
        reason: 'file_too_large',
        details: {
          size: file.size,
          maxSize: this.config.maxFileSize,
        },
      };
    }

    // MIME类型验证
    if (!this.isValidMimeType(file.type)) {
      return {
        valid: false,
        reason: 'invalid_mime_type',
        details: { type: file.type },
      };
    }

    // 文件扩展名验证
    if (!this.isValidExtension(file.name)) {
      return {
        valid: false,
        reason: 'invalid_extension',
        details: { name: file.name },
      };
    }

    // 文件内容扫描（可选）
    if (this.config.scanFileContent) {
      const contentResult = await this.scanContent(file);
      if (!contentResult.valid) {
        return contentResult;
      }
    }

    return { valid: true };
  }

  // MIME类型验证
  private isValidMimeType(mimeType: string): boolean {
    // 如果在禁止列表中，直接拒绝
    if (this.config.disallowedMimeTypes.some(pattern => this.matchMimePattern(mimeType, pattern))) {
      return false;
    }

    // 如果允许列表为 ['*/*'] 表示允许所有类型
    if (this.config.allowedMimeTypes.includes('*/*')) {
      return true;
    }

    // 检查是否在允许列表中
    return this.config.allowedMimeTypes.some(pattern => this.matchMimePattern(mimeType, pattern));
  }

  // MIME模式匹配
  private matchMimePattern(mimeType: string, pattern: string): boolean {
    if (pattern === '*/*') return true;

    const [typePattern, subtypePattern] = pattern.split('/');
    const [type, subtype] = mimeType.split('/');

    const typeMatch = typePattern === '*' || typePattern === type;
    const subtypeMatch = subtypePattern === '*' || subtypePattern === subtype;

    return typeMatch && subtypeMatch;
  }

  // 文件扩展名验证
  private isValidExtension(filename: string): boolean {
    if (!this.config.allowedExtensions) return true;

    const extension = filename.split('.').pop()?.toLowerCase() || '';
    return this.config.allowedExtensions.includes(extension);
  }

  // 文件内容扫描
  private async scanContent(file: File): Promise<ValidationResult> {
    // 文件头部签名检查
    const headerResult = await this.checkFileHeader(file);
    if (!headerResult.valid) {
      return headerResult;
    }

    // 可疑内容检测
    if (this.config.detectMaliciousContent) {
      const malwareResult = await this.detectMaliciousPatterns(file);
      if (!malwareResult.valid) {
        return malwareResult;
      }
    }

    return { valid: true };
  }

  // 检查文件头部签名（魔术数字）
  private async checkFileHeader(file: File): Promise<ValidationResult> {
    // 实现文件头部检查
    return { valid: true };
  }

  // 检测恶意内容模式
  private async detectMaliciousPatterns(file: File): Promise<ValidationResult> {
    // 实现恶意内容检测
    return { valid: true };
  }

  // 权限验证集成
  async validatePermissions(file: File, user: UserContext): Promise<ValidationResult> {
    // 如果配置了权限验证服务
    if (this.config.permissionValidator) {
      return await this.config.permissionValidator(file, user);
    }

    return { valid: true };
  }
}
```

### 11. 性能优化

增加预加载和网络适应性策略：

```typescript
// 网络检测器
class NetworkDetector {
  private listeners: Array<(network: NetworkInfo) => void> = [];
  private currentNetwork: NetworkInfo = {
    online: navigator.onLine,
    type: this.getConnectionType(),
    speed: 0,
    rtt: 0,
  };

  constructor() {
    // 监听在线状态
    window.addEventListener('online', () => this.updateNetworkInfo());
    window.addEventListener('offline', () => this.updateNetworkInfo());

    // 如果支持Network Information API
    if ('connection' in navigator) {
      const connection = (navigator as any).connection;
      connection.addEventListener('change', () => this.updateNetworkInfo());
    }

    // 初始化网络信息
    this.updateNetworkInfo();

    // 定期测量网络速度
    setInterval(() => this.measureNetworkSpeed(), 60000);
  }

  getCurrentNetwork(): NetworkInfo {
    return { ...this.currentNetwork };
  }

  onNetworkChange(callback: (network: NetworkInfo) => void): () => void {
    this.listeners.push(callback);

    // 返回取消订阅的函数
    return () => {
      this.listeners = this.listeners.filter(cb => cb !== callback);
    };
  }

  private updateNetworkInfo(): void {
    const oldNetwork = { ...this.currentNetwork };

    this.currentNetwork.online = navigator.onLine;
    this.currentNetwork.type = this.getConnectionType();

    if ('connection' in navigator) {
      const connection = (navigator as any).connection;
      this.currentNetwork.rtt = connection.rtt;

      // 如果有effectiveType属性，根据它估计速度
      if (connection.effectiveType) {
        this.currentNetwork.speed = this.estimateSpeedFromEffectiveType(connection.effectiveType);
      }
    }

    // 通知监听器
    if (JSON.stringify(oldNetwork) !== JSON.stringify(this.currentNetwork)) {
      this.notifyListeners();
    }
  }

  private getConnectionType(): 'wifi' | 'cellular' | 'ethernet' | 'unknown' {
    if (!('connection' in navigator)) return 'unknown';

    const connection = (navigator as any).connection;
    if (!connection.type) return 'unknown';

    switch (connection.type) {
      case 'wifi':
        return 'wifi';
      case 'cellular':
        return 'cellular';
      case 'ethernet':
        return 'ethernet';
      default:
        return 'unknown';
    }
  }

  private estimateSpeedFromEffectiveType(effectiveType: string): number {
    // 根据effectiveType估计速度 (Mbps)
    switch (effectiveType) {
      case 'slow-2g':
        return 0.1;
      case '2g':
        return 0.5;
      case '3g':
        return 2;
      case '4g':
        return 10;
      default:
        return 1;
    }
  }

  private notifyListeners(): void {
    this.listeners.forEach(callback => {
      try {
        callback(this.currentNetwork);
      } catch (err) {
        console.error('网络状态监听回调错误:', err);
      }
    });
  }

  // 测量实际网络速度
  private async measureNetworkSpeed(): Promise<void> {
    if (!navigator.onLine) return;

    try {
      const startTime = performance.now();
      const response = await fetch('/ping', { method: 'GET', cache: 'no-store' });
      const endTime = performance.now();

      if (response.ok) {
        const rtt = endTime - startTime;
        this.currentNetwork.rtt = rtt;

        // 根据RTT估算速度
        if (rtt < 50) {
          this.currentNetwork.speed = 20; // 高速连接
        } else if (rtt < 100) {
          this.currentNetwork.speed = 10; // 良好连接
        } else if (rtt < 200) {
          this.currentNetwork.speed = 5; // 中等连接
        } else if (rtt < 500) {
          this.currentNetwork.speed = 2; // 慢速连接
        } else {
          this.currentNetwork.speed = 0.5; // 非常慢的连接
        }

        this.notifyListeners();
      }
    } catch (err) {
      // 忽略错误，保持当前速度估计
    }
  }
}

// 自适应上传控制器
class AdaptiveUploadController {
  private networkDetector: NetworkDetector;
  private config: AdaptiveConfig;

  private currentChunkSize: number;
  private currentConcurrency: number;

  constructor(networkDetector: NetworkDetector, config: AdaptiveConfig) {
    this.networkDetector = networkDetector;
    this.config = {
      baseChunkSize: 2 * 1024 * 1024, // 2MB
      baseConcurrency: 3,
      minChunkSize: 256 * 1024, // 最小分片大小256KB
      maxChunkSize: 10 * 1024 * 1024, // 最大分片大小10MB
      minConcurrency: 1,
      maxConcurrency: 6,
      ...config,
    };

    // 初始化设置
    const network = networkDetector.getCurrentNetwork();
    this.adjustSettings(network);

    // 监听网络变化
    this.networkDetector.onNetworkChange(network => {
      this.adjustSettings(network);
    });
  }

  // 获取当前最优设置
  getOptimalSettings(): UploadSettings {
    return {
      chunkSize: this.currentChunkSize,
      concurrency: this.currentConcurrency,
    };
  }

  // 根据网络状况调整设置
  private adjustSettings(network: NetworkInfo): void {
    // 离线情况
    if (!network.online) {
      this.currentChunkSize = this.config.minChunkSize;
      this.currentConcurrency = this.config.minConcurrency;
      return;
    }

    // 根据网速调整分片大小
    if (network.speed > 10) {
      // 高速连接
      this.currentChunkSize = this.config.maxChunkSize;
    } else if (network.speed > 5) {
      // 中速连接
      this.currentChunkSize = this.config.baseChunkSize;
    } else if (network.speed > 2) {
      // 低速连接
      this.currentChunkSize = this.config.baseChunkSize / 2;
    } else {
      // 极低速连接
      this.currentChunkSize = this.config.minChunkSize;
    }

    // 根据网络类型调整并发数
    if (network.type === 'wifi' || network.type === 'ethernet') {
      this.currentConcurrency = Math.min(Math.ceil(network.speed / 2), this.config.maxConcurrency);
    } else if (network.type === 'cellular') {
      // 移动网络降低并发，避免过度消耗流量
      this.currentConcurrency = Math.min(Math.ceil(network.speed / 3), this.config.maxConcurrency);
    } else {
      this.currentConcurrency = this.config.baseConcurrency;
    }

    // 确保设置在合理范围内
    this.currentChunkSize = Math.max(
      this.config.minChunkSize,
      Math.min(this.currentChunkSize, this.config.maxChunkSize),
    );

    this.currentConcurrency = Math.max(
      this.config.minConcurrency,
      Math.min(this.currentConcurrency, this.config.maxConcurrency),
    );
  }
}
```

### 12. 本地缓存优化设计

增强的IndexedDB存储策略：

```typescript
// 增强的存储管理器
class StorageManager {
  private dbName: string;
  private storeName: string;
  private db: IDBDatabase | null = null;
  private ready: Promise<void>;

  constructor(options: StorageOptions = {}) {
    this.dbName = options.dbName || 'file-uploader-storage';
    this.storeName = options.storeName || 'uploads';
    this.ready = this.initDB();
  }

  // 初始化数据库
  private async initDB(): Promise<void> {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, 1);

      request.onerror = () => {
        console.error('无法打开IndexedDB');
        reject(new Error('IndexedDB访问被拒绝'));
      };

      request.onsuccess = () => {
        this.db = request.result;
        resolve();
      };

      request.onupgradeneeded = event => {
        const db = request.result;

        // 创建对象存储
        if (!db.objectStoreNames.contains(this.storeName)) {
          const store = db.createObjectStore(this.storeName, { keyPath: 'id' });
          store.createIndex('fileId', 'fileId', { unique: false });
          store.createIndex('createdAt', 'createdAt', { unique: false });
        }
      };
    });
  }

  // 保存上传状态
  async saveUploadState(fileId: string, state: UploadState): Promise<void> {
    await this.ready;

    return new Promise((resolve, reject) => {
      if (!this.db) {
        reject(new Error('数据库未初始化'));
        return;
      }

      try {
        const transaction = this.db.transaction([this.storeName], 'readwrite');
        const store = transaction.objectStore(this.storeName);

        // 准备数据
        const data = {
          id: `state_${fileId}`,
          fileId,
          type: 'state',
          data: state,
          createdAt: Date.now(),
          updatedAt: Date.now(),
        };

        // 保存
        const request = store.put(data);

        request.onsuccess = () => resolve();
        request.onerror = () => reject(new Error('保存上传状态失败'));
      } catch (err) {
        reject(err);
      }
    });
  }

  // 保存文件分片
  async saveChunk(fileId: string, chunkIndex: number, chunk: Blob): Promise<void> {
    await this.ready;

    return new Promise((resolve, reject) => {
      if (!this.db) {
        reject(new Error('数据库未初始化'));
        return;
      }

      try {
        const transaction = this.db.transaction([this.storeName], 'readwrite');
        const store = transaction.objectStore(this.storeName);

        // 准备数据
        const data = {
          id: `chunk_${fileId}_${chunkIndex}`,
          fileId,
          type: 'chunk',
          chunkIndex,
          data: chunk,
          size: chunk.size,
          createdAt: Date.now(),
        };

        // 保存
        const request = store.put(data);

        request.onsuccess = () => resolve();
        request.onerror = () => reject(new Error('保存分片失败'));
      } catch (err) {
        reject(err);
      }
    });
  }

  // 获取上传状态
  async getUploadState(fileId: string): Promise<UploadState | null> {
    await this.ready;

    return new Promise((resolve, reject) => {
      if (!this.db) {
        reject(new Error('数据库未初始化'));
        return;
      }

      try {
        const transaction = this.db.transaction([this.storeName], 'readonly');
        const store = transaction.objectStore(this.storeName);

        const request = store.get(`state_${fileId}`);

        request.onsuccess = () => {
          const result = request.result;
          resolve(result ? result.data : null);
        };

        request.onerror = () => reject(new Error('获取上传状态失败'));
      } catch (err) {
        reject(err);
      }
    });
  }

  // 获取文件分片
  async getChunk(fileId: string, chunkIndex: number): Promise<Blob | null> {
    await this.ready;

    return new Promise((resolve, reject) => {
      if (!this.db) {
        reject(new Error('数据库未初始化'));
        return;
      }

      try {
        const transaction = this.db.transaction([this.storeName], 'readonly');
        const store = transaction.objectStore(this.storeName);

        const request = store.get(`chunk_${fileId}_${chunkIndex}`);

        request.onsuccess = () => {
          const result = request.result;
          resolve(result ? result.data : null);
        };

        request.onerror = () => reject(new Error('获取分片失败'));
      } catch (err) {
        reject(err);
      }
    });
  }

  // 获取文件的所有分片索引
  async getChunkIndices(fileId: string): Promise<number[]> {
    await this.ready;

    return new Promise((resolve, reject) => {
      if (!this.db) {
        reject(new Error('数据库未初始化'));
        return;
      }

      try {
        const transaction = this.db.transaction([this.storeName], 'readonly');
        const store = transaction.objectStore(this.storeName);
        const index = store.index('fileId');

        const request = index.getAll(fileId);

        request.onsuccess = () => {
          const results = request.result;
          const chunkIndices = results
            .filter(item => item.type === 'chunk')
            .map(item => item.chunkIndex);

          resolve(chunkIndices);
        };

        request.onerror = () => reject(new Error('获取分片索引失败'));
      } catch (err) {
        reject(err);
      }
    });
  }

  // 删除文件相关数据
  async deleteFile(fileId: string): Promise<void> {
    await this.ready;

    return new Promise((resolve, reject) => {
      if (!this.db) {
        reject(new Error('数据库未初始化'));
        return;
      }

      try {
        const transaction = this.db.transaction([this.storeName], 'readwrite');
        const store = transaction.objectStore(this.storeName);
        const index = store.index('fileId');

        const request = index.getAll(fileId);

        request.onsuccess = () => {
          const results = request.result;

          // 删除所有相关记录
          const deleteTransaction = this.db!.transaction([this.storeName], 'readwrite');
          const deleteStore = deleteTransaction.objectStore(this.storeName);

          let deletedCount = 0;

          results.forEach(item => {
            const deleteRequest = deleteStore.delete(item.id);

            deleteRequest.onsuccess = () => {
              deletedCount++;
              if (deletedCount === results.length) {
                resolve();
              }
            };

            deleteRequest.onerror = () => {
              reject(new Error('删除文件数据失败'));
            };
          });

          // 如果没有记录，直接解析
          if (results.length === 0) {
            resolve();
          }
        };

        request.onerror = () => reject(new Error('获取文件数据失败'));
      } catch (err) {
        reject(err);
      }
    });
  }

  // 清理过期数据
  async cleanupExpiredData(maxAge: number = 7 * 24 * 60 * 60 * 1000): Promise<void> {
    await this.ready;

    return new Promise((resolve, reject) => {
      if (!this.db) {
        reject(new Error('数据库未初始化'));
        return;
      }

      try {
        const transaction = this.db.transaction([this.storeName], 'readwrite');
        const store = transaction.objectStore(this.storeName);
        const index = store.index('createdAt');

        const now = Date.now();
        const range = IDBKeyRange.upperBound(now - maxAge);

        const request = index.openCursor(range);

        request.onsuccess = event => {
          const cursor = (event.target as IDBRequest).result;

          if (cursor) {
            store.delete(cursor.value.id);
            cursor.continue();
          } else {
            resolve();
          }
        };

        request.onerror = () => reject(new Error('清理过期数据失败'));
      } catch (err) {
        reject(err);
      }
    });
  }

  // 获取存储使用情况
  async getStorageUsage(): Promise<StorageUsage> {
    await this.ready;

    return new Promise((resolve, reject) => {
      if (!this.db) {
        reject(new Error('数据库未初始化'));
        return;
      }

      try {
        const transaction = this.db.transaction([this.storeName], 'readonly');
        const store = transaction.objectStore(this.storeName);

        const request = store.getAll();

        request.onsuccess = () => {
          const results = request.result;

          let totalSize = 0;
          let chunkCount = 0;
          let fileCount = 0;
          const fileIds = new Set();

          results.forEach(item => {
            if (item.type === 'chunk') {
              totalSize += item.size || 0;
              chunkCount++;
              fileIds.add(item.fileId);
            }
          });

          fileCount = fileIds.size;

          resolve({
            totalSize,
            chunkCount,
            fileCount,
          });
        };

        request.onerror = () => reject(new Error('获取存储使用情况失败'));
      } catch (err) {
        reject(err);
      }
    });
  }
}
```

### 13. 监控与分析

增加监控与分析模块：

```typescript
// 性能指标收集器
class MetricsCollector {
  private metrics: {
    uploads: UploadMetric[];
    errors: ErrorMetric[];
    performance: PerformanceMetric[];
  };

  private config: MetricsConfig;

  constructor(config: MetricsConfig = {}) {
    this.metrics = {
      uploads: [],
      errors: [],
      performance: [],
    };

    this.config = {
      maxEntries: 100,
      enabled: true,
      ...config,
    };
  }

  // 记录上传指标
  recordUpload(metric: UploadMetric): void {
    if (!this.config.enabled) return;

    this.metrics.uploads.push({
      timestamp: Date.now(),
      ...metric,
    });

    this.truncateMetrics('uploads');
  }

  // 记录错误指标
  recordError(error: Error | UploadError, context: any = {}): void {
    if (!this.config.enabled) return;

    this.metrics.errors.push({
      timestamp: Date.now(),
      error: {
        message: error.message,
        name: error.name,
        code: (error as UploadError).code,
        stack: error.stack,
      },
      context,
    });

    this.truncateMetrics('errors');
  }

  // 记录性能指标
  recordPerformance(metric: PerformanceMetric): void {
    if (!this.config.enabled) return;

    this.metrics.performance.push({
      timestamp: Date.now(),
      ...metric,
    });

    this.truncateMetrics('performance');
  }

  // 获取上传统计数据
  getUploadStats(): UploadStats {
    if (!this.config.enabled) return { success: 0, failed: 0, avgSpeed: 0, avgTime: 0 };

    const uploads = this.metrics.uploads;

    // 基本统计
    const total = uploads.length;
    const success = uploads.filter(m => m.success).length;
    const failed = total - success;

    // 速度和时间统计
    let totalSpeed = 0;
    let totalTime = 0;
    let successfulUploads = 0;

    uploads.forEach(upload => {
      if (upload.success && upload.speed && upload.duration) {
        totalSpeed += upload.speed;
        totalTime += upload.duration;
        successfulUploads++;
      }
    });

    const avgSpeed = successfulUploads ? totalSpeed / successfulUploads : 0;
    const avgTime = successfulUploads ? totalTime / successfulUploads : 0;

    return {
      total,
      success,
      failed,
      avgSpeed,
      avgTime,
    };
  }

  // 获取错误摘要
  getErrorSummary(timeWindow: number = 3600000): ErrorReport {
    if (!this.config.enabled) return { count: 0, types: {} };

    const now = Date.now();
    const relevantErrors = this.metrics.errors.filter(e => e.timestamp >= now - timeWindow);

    // 分类错误
    const errorTypes: Record<string, number> = {};

    relevantErrors.forEach(error => {
      const code = error.error.code || 'unknown';
      errorTypes[code] = (errorTypes[code] || 0) + 1;
    });

    return {
      count: relevantErrors.length,
      types: errorTypes,
    };
  }

  // 获取性能分析
  getPerformanceAnalysis(): PerformanceReport {
    if (!this.config.enabled) {
      return {
        avgHashTime: 0,
        avgChunkTime: 0,
        avgUploadTime: 0,
        bottlenecks: [],
      };
    }

    const metrics = this.metrics.performance;

    // 计算各阶段平均时间
    const hashMetrics = metrics.filter(m => m.operation === 'hash');
    const chunkMetrics = metrics.filter(m => m.operation === 'chunk');
    const uploadMetrics = metrics.filter(m => m.operation === 'upload');

    const avgHashTime = this.calculateAverage(hashMetrics, 'duration');
    const avgChunkTime = this.calculateAverage(chunkMetrics, 'duration');
    const avgUploadTime = this.calculateAverage(uploadMetrics, 'duration');

    // 确定性能瓶颈
    const bottlenecks = this.identifyBottlenecks([
      { name: 'hash', time: avgHashTime },
      { name: 'chunk', time: avgChunkTime },
      { name: 'upload', time: avgUploadTime },
    ]);

    return {
      avgHashTime,
      avgChunkTime,
      avgUploadTime,
      bottlenecks,
    };
  }

  // 导出指标数据
  exportMetrics(): MetricsData {
    return {
      ...this.metrics,
      stats: {
        uploads: this.getUploadStats(),
        errors: this.getErrorSummary(),
        performance: this.getPerformanceAnalysis(),
      },
    };
  }

  // 清除所有指标
  clearMetrics(): void {
    this.metrics = {
      uploads: [],
      errors: [],
      performance: [],
    };
  }

  // 限制指标数量
  private truncateMetrics(type: 'uploads' | 'errors' | 'performance'): void {
    if (this.metrics[type].length > this.config.maxEntries) {
      this.metrics[type] = this.metrics[type].slice(-this.config.maxEntries);
    }
  }

  // 计算平均值
  private calculateAverage(metrics: any[], field: string): number {
    if (!metrics.length) return 0;

    const sum = metrics.reduce((acc, m) => acc + (m[field] || 0), 0);
    return sum / metrics.length;
  }

  // 识别性能瓶颈
  private identifyBottlenecks(operations: { name: string; time: number }[]): string[] {
    // 计算总时间
    const totalTime = operations.reduce((sum, op) => sum + op.time, 0);

    // 瓶颈阈值（占总时间的40%以上）
    const threshold = totalTime * 0.4;

    return operations.filter(op => op.time >= threshold).map(op => op.name);
  }
}
```

### 14. 开发者模式设计

为方便开发者调试，特别设计了开发者模式，该模式可在配置中启用，会在控制台输出所有核心功能的日志。

#### 开发者模式配置

```typescript
// 开发者模式配置接口
interface DevModeConfig {
  enabled: boolean; // 是否启用开发者模式
  logLevel: 'debug' | 'info' | 'warn' | 'error'; // 日志级别
  logFilter?: Array<string>; // 日志类别过滤
  logFormat?: 'pretty' | 'json'; // 日志格式
  performanceMonitoring?: boolean; // 是否监控性能
  networkLogging?: boolean; // 是否记录网络请求
  workerLogging?: boolean; // 是否记录Worker操作
  pluginTracing?: boolean; // 是否追踪插件调用链
}

// 开发者模式配置示例
const uploader = new FileUploader({
  target: 'https://api.example.com/upload',
  devMode: {
    enabled: true,
    logLevel: 'debug',
    logFilter: ['network', 'worker', 'plugin'],
    logFormat: 'pretty',
    performanceMonitoring: true,
    networkLogging: true,
  },
});

// 简化配置
const uploader = new FileUploader({
  target: 'https://api.example.com/upload',
  devMode: true, // 使用默认开发者模式配置
});
```

#### 日志系统设计

```typescript
// 增强的日志系统
class Logger {
  private config: LoggerConfig;
  private prefix: string;
  static instance: Logger | null = null;

  private constructor(config: LoggerConfig = {}, prefix: string = '') {
    this.config = {
      level: 'info',
      format: 'pretty',
      enabled: false,
      ...config,
    };
    this.prefix = prefix;
  }

  // 单例模式获取或创建Logger实例
  static getInstance(config?: LoggerConfig, prefix?: string): Logger {
    if (!Logger.instance) {
      Logger.instance = new Logger(config, prefix);
    } else if (config) {
      Logger.instance.updateConfig(config);
      if (prefix) Logger.instance.prefix = prefix;
    }
    return Logger.instance;
  }

  // 更新配置
  updateConfig(config: Partial<LoggerConfig>): void {
    this.config = { ...this.config, ...config };
  }

  // 日志级别方法
  debug(message: string, data?: any, category?: string): void {
    this.log('debug', message, data, category);
  }

  info(message: string, data?: any, category?: string): void {
    this.log('info', message, data, category);
  }

  warn(message: string, data?: any, category?: string): void {
    this.log('warn', message, data, category);
  }

  error(message: string, data?: any, category?: string): void {
    this.log('error', message, data, category);
  }

  // 内部日志处理方法
  private log(level: LogLevel, message: string, data?: any, category?: string): void {
    if (!this.config.enabled) return;
    if (!this.isLevelEnabled(level)) return;
    if (category && this.config.filter && !this.config.filter.includes(category)) return;

    const timestamp = new Date().toISOString();
    const prefix = this.prefix ? `[${this.prefix}] ` : '';
    const categoryStr = category ? `[${category}] ` : '';

    if (this.config.format === 'json') {
      const logData = {
        timestamp,
        level,
        message: `${prefix}${categoryStr}${message}`,
        data,
      };
      this.output(level, JSON.stringify(logData));
    } else {
      let formattedMessage = `${timestamp} ${level.toUpperCase()} ${prefix}${categoryStr}${message}`;

      // 美化输出
      if (data) {
        if (typeof data === 'object') {
          try {
            formattedMessage += `\n${JSON.stringify(data, null, 2)}`;
          } catch (e) {
            formattedMessage += `\n[无法序列化的数据]`;
          }
        } else {
          formattedMessage += ` ${data}`;
        }
      }
      this.output(level, formattedMessage);
    }
  }

  // 检查日志级别是否启用
  private isLevelEnabled(level: LogLevel): boolean {
    const levels: LogLevel[] = ['debug', 'info', 'warn', 'error'];
    const configLevelIndex = levels.indexOf(this.config.level);
    const logLevelIndex = levels.indexOf(level);
    return logLevelIndex >= configLevelIndex;
  }

  // 输出日志
  private output(level: LogLevel, message: string): void {
    switch (level) {
      case 'debug':
        console.debug(message);
        break;
      case 'info':
        console.info(message);
        break;
      case 'warn':
        console.warn(message);
        break;
      case 'error':
        console.error(message);
        break;
    }
  }

  // 创建子日志器，继承父配置
  createSubLogger(prefix: string): Logger {
    const subLogger = new Logger(this.config, `${this.prefix}:${prefix}`);
    return subLogger;
  }
}
```

#### 开发者模式实现

```typescript
// 开发者模式插件
const devModePlugin = (options: DevModeConfig | boolean = true): Plugin => ({
  name: 'dev-mode',
  version: '1.0.0',
  install: (uploader, opts) => {
    // 处理布尔值配置
    const config: DevModeConfig =
      options === true
        ? {
            enabled: true,
            logLevel: 'info',
          }
        : (options as DevModeConfig);

    // 初始化日志系统
    const logger = Logger.getInstance({
      level: config.logLevel,
      format: config.logFormat || 'pretty',
      enabled: config.enabled,
      filter: config.logFilter,
    });

    // 注入日志记录器
    uploader.logger = logger;

    // 监听上传事件
    uploader.on('upload:start', file => {
      logger.info(
        `开始上传文件: ${file.name}`,
        {
          fileSize: file.size,
          fileType: file.type,
        },
        'core',
      );
    });

    uploader.on('upload:progress', progress => {
      logger.debug(`上传进度: ${progress}%`, null, 'core');
    });

    uploader.on('upload:success', result => {
      logger.info(`上传成功: ${result.url}`, result, 'core');
    });

    uploader.on('upload:error', error => {
      logger.error(`上传失败: ${error.message}`, error, 'core');
    });

    // 监听网络请求（如果启用）
    if (config.networkLogging) {
      uploader.on('network:request', request => {
        logger.debug(`发送请求: ${request.method} ${request.url}`, request, 'network');
      });

      uploader.on('network:response', response => {
        logger.debug(`接收响应: ${response.status}`, response, 'network');
      });

      uploader.on('network:error', error => {
        logger.error(`网络错误: ${error.message}`, error, 'network');
      });
    }

    // 监听Worker操作（如果启用）
    if (config.workerLogging) {
      uploader.on('worker:task', task => {
        logger.debug(`Worker任务: ${task.type}`, task, 'worker');
      });

      uploader.on('worker:result', result => {
        logger.debug(`Worker结果`, result, 'worker');
      });
    }

    // 监听插件调用链（如果启用）
    if (config.pluginTracing) {
      uploader.on('plugin:before', (hookName, plugin) => {
        logger.debug(`执行插件钩子: ${plugin.name}.${hookName} (开始)`, null, 'plugin');
      });

      uploader.on('plugin:after', (hookName, plugin, duration) => {
        logger.debug(
          `执行插件钩子: ${plugin.name}.${hookName} (完成)`,
          { duration: `${duration}ms` },
          'plugin',
        );
      });
    }

    // 性能监控（如果启用）
    if (config.performanceMonitoring) {
      const metricsCollector = new MetricsCollector({ enabled: true });

      uploader.on('upload:start', () => {
        performance.mark('upload-start');
      });

      uploader.on('upload:end', () => {
        performance.mark('upload-end');
        const measure = performance.measure('upload-duration', 'upload-start', 'upload-end');
        metricsCollector.recordPerformance({
          operation: 'upload',
          duration: measure.duration,
        });

        logger.info(
          `上传性能指标`,
          {
            duration: `${Math.round(measure.duration)}ms`,
          },
          'performance',
        );
      });
    }
  },
});
```

#### 开发者模式使用示例

```typescript
// 基本用法
import { FileUploader } from '@file-chunk-uploader/core';
import { devMode } from '@file-chunk-uploader/utils';

const uploader = new FileUploader({
  target: 'https://api.example.com/upload',
});

// 启用开发者模式（带自定义配置）
uploader.use(
  devMode({
    enabled: true,
    logLevel: 'debug',
    logFilter: ['network', 'core'],
    performanceMonitoring: true,
  }),
);

// 或者通过配置选项直接启用
const uploader = new FileUploader({
  target: 'https://api.example.com/upload',
  devMode: true, // 使用默认开发者模式配置
});
```

开发者模式主要功能包括：

1. **详细日志输出**：在控制台输出所有核心功能的运行日志
2. **多级别日志**：支持debug、info、warn、error四种日志级别
3. **分类过滤**：可按功能模块过滤日志输出
4. **网络请求日志**：记录所有上传相关的网络请求和响应
5. **性能监控**：测量和记录关键操作的执行时间
6. **插件调用链跟踪**：监控插件生命周期钩子的执行过程
7. **自定义格式化**：支持JSON格式或美化格式的日志输出

开发者模式的设计目标是为开发者提供完整的调试工具链，同时保证在生产环境中不会影响性能和用户体验。

### 15. 包大小优化策略

通过微包架构和插件系统，实现"按需加载"，用户可以只安装和引入需要的功能：

```typescript
// 最小化引入 (~3KB gzipped)
import { FileUploader } from '@file-chunk-uploader/core';
import { fetchAdapter } from '@file-chunk-uploader/network/fetch-adapter';

const uploader = new FileUploader({
  target: 'https://api.example.com/upload',
  networkAdapter: fetchAdapter(),
});

// 标准功能引入 (~10KB gzipped)
import { FileUploader } from '@file-chunk-uploader/standard';

// 完整功能引入 (~25KB gzipped)
import { FileUploader } from '@file-chunk-uploader/full';
```

入口包定义:

```typescript
// @file-chunk-uploader/standard/src/index.ts
import { FileUploader } from '@file-chunk-uploader/core';
import { chunkUpload } from '@file-chunk-uploader/chunk';
import { resumable } from '@file-chunk-uploader/resume';
import { fetchAdapter } from '@file-chunk-uploader/network';
import { errorHandler } from '@file-chunk-uploader/errors';

// 预配置标准功能
export class StandardUploader extends FileUploader {
  constructor(options = {}) {
    super(options);

    // 自动加载核心插件
    this.use(fetchAdapter());
    this.use(chunkUpload({ chunkSize: options.chunkSize || 2 * 1024 * 1024 }));
    this.use(resumable({ enabled: options.resumable !== false }));
    this.use(errorHandler({ retryCount: options.retryCount || 3 }));
  }
}

export { FileUploader };
export default StandardUploader;
```

## 技术选择

- **核心**: TypeScript
- **构建工具**:
  - esbuild (开发环境 - 更快的构建速度)
  - Rollup (生产环境 - 更好的tree-shaking支持)
- **测试框架**: Jest
- **代码质量**: ESLint + Prettier
- **文档**: TypeDoc + Storybook
- **包管理**: PNPM (更好的Monorepo支持)
- **Monorepo管理**: Turborepo (替代Lerna，提供更好的缓存机制)

## 框架适配包明确支持版本

| 框架    | 最低支持版本 | 特性支持                | 服务端渲染       |
| ------- | ------------ | ----------------------- | ---------------- |
| React   | React 16.8+  | Hooks, Context, SSR     | ✅ 完全支持      |
| Vue     | Vue 3.0+     | Composables, Components | ✅ 支持Nuxt 3    |
| Angular | Angular 13+  | Services, Directives    | ✅ 支持Universal |
| Svelte  | Svelte 3+    | Stores, Components      | ✅ 基本支持      |

## 框架特性对比

| 特性           | 原生JS | React | Vue | Angular | Svelte |
| -------------- | ------ | ----- | --- | ------- | ------ |
| 文件选择组件   | ✅     | ✅    | ✅  | ✅      | ✅     |
| 拖放区域       | ✅     | ✅    | ✅  | ✅      | ✅     |
| 进度UI         | ✅     | ✅    | ✅  | ✅      | ✅     |
| 状态管理集成   | -      | ✅    | ✅  | ✅      | ✅     |
| 服务端组件支持 | -      | ✅    | ✅  | ✅      | ✅     |
| 指令支持       | -      | -     | ✅  | ✅      | -      |
| TypeScript支持 | ✅     | ✅    | ✅  | ✅      | ✅     |
| 自定义钩子     | ✅     | ✅    | ✅  | ✅      | ✅     |
| Observable支持 | ✅     | ✅    | ✅  | ✅      | ✅     |
| SSR安全        | -      | ✅    | ✅  | ✅      | ✅     |

## CI/CD流程设计

```
github-workflow/
├── ci.yml                     # 持续集成工作流
│   ├── 代码检查 (lint + type-check)
│   ├── 单元测试 (jest)
│   ├── 集成测试
│   └── 打包验证
│
├── release.yml                # 发布工作流
│   ├── 版本检查
│   ├── 变更日志生成
│   ├── 构建
│   ├── 测试
│   └── 发布到NPM
│
└── docs.yml                   # 文档部署工作流
    ├── 构建文档
    ├── 构建示例应用
    └── 部署到GitHub Pages
```

## 产品路线图

1. v1.0: 基础功能 - 分片上传、断点续传、核心模块
2. v1.1: 框架适配 - 发布React、Vue、原生JS适配器
3. v1.2: Worker增强 - 完整Worker池、并行处理优化
4. v1.3: 性能优化 - 智能调度、内存管理优化、网络自适应
5. v1.4: 安全强化 - 加密传输、完整性校验、内容扫描
6. v1.5: 监控与分析 - 性能指标、错误聚合、使用分析
7. v2.0: 高级特性 - 增强的插件系统、自定义存储适配器

## 总结

这个优化后的设计方案融合了现代前端工程最佳实践，并针对大文件上传场景进行了全面增强。通过多框架适配设计和Web Worker增强，既保证了易用性和广泛的兼容性，又具备了高性能、高扩展性和健壮性。核心特点包括：

1. **模块化设计**: 清晰的责任分离和高内聚低耦合
2. **多框架支持**: 原生JS、React、Vue等框架的无缝集成与SSR支持
3. **高性能处理**: Web Worker并行计算、网络自适应策略和优化的数据传输
4. **可扩展性**: 增强的插件系统和生命周期管理
5. **安全可靠**: 全面的错误处理、恢复机制和安全检验
6. **轻量与优化**: 分层打包策略确保最小化包体积
7. **开发者友好**: 全面的监控与分析能力，支持Observable API

这一设计不仅满足了当前需求，还为未来的功能扩展和性能优化提供了坚实基础，同时考虑了用户体验、开发者体验和长期可维护性的平衡。

## 项目初始化

项目采用插件化微包架构，使用pnpm作为包管理工具，Turborepo进行工作流管理。每个功能模块都是独立的微包，可以单独发布和使用，通过插件系统组合功能。

### 技术栈选择

- **包管理**: pnpm
- **Monorepo管理**: Turborepo
- **构建工具**: Rollup (生产环境)，Vite (开发环境)
- **语言**: TypeScript
- **测试**: Jest
- **代码质量**: ESLint + Prettier
- **版本管理**: Changesets
- **CI/CD**: GitHub Actions

### 目录结构

```
file-chunk-uploader/
├── packages/                # 所有微包
│   ├── core/                # 核心最小功能
│   ├── chunk/               # 分片上传功能
│   ├── resume/              # 断点续传功能
│   ├── fast/                # 秒传功能
│   ├── network/             # 网络请求功能
│   ├── security/            # 安全功能
│   ├── utils/               # 工具函数
│   ├── errors/              # 错误处理
│   ├── monitoring/          # 监控分析
│   ├── workers/             # Worker功能
│   ├── standard/            # 标准功能集成
│   ├── full/                # 完整功能集成
│   ├── react/               # React适配器
│   ├── vue/                 # Vue适配器
│   └── vanilla/             # 原生JS适配器
├── examples/                # 示例应用
│   ├── vanilla/             # 原生JS示例
│   ├── react/               # React示例
│   └── vue/                 # Vue示例
├── workers/                 # Worker脚本
├── docs/                    # 文档
├── scripts/                 # 构建和开发脚本
└── .github/                 # GitHub配置
```

### 开发流程

1. **安装依赖**: `pnpm install`
2. **开发模式**: `pnpm dev`
3. **构建**: `pnpm build`
4. **测试**: `pnpm test`
5. **代码检查**: `pnpm lint`
6. **发布流程**:
   - 创建变更集: `pnpm changeset`
   - 更新版本: `pnpm version-packages`
   - 发布: `pnpm release`

### 包依赖关系

插件化微包架构中的依赖关系更加清晰：

```
core (基础上传器)
  ↑
  ├── chunk (依赖core)
  ├── resume (依赖core)
  ├── network (依赖core)
  ├── security (依赖core)
  └── errors (依赖core)
      ↑
      ├── standard (依赖多个基础功能包)
      └── full (依赖所有功能包)
          ↑
          ├── react (依赖standard或core)
          ├── vue (依赖standard或core)
          └── vanilla (依赖standard或core)
```

每个包都是可选的，用户可以根据需求自由组合。

## 总结

这个优化后的设计方案融合了现代前端工程最佳实践，并针对大文件上传场景进行了全面增强。通过多框架适配设计和Web Worker增强，既保证了易用性和广泛的兼容性，又具备了高性能、高扩展性和健壮性。核心特点包括：

1. **模块化设计**: 清晰的责任分离和高内聚低耦合
2. **多框架支持**: 原生JS、React、Vue等框架的无缝集成与SSR支持
3. **高性能处理**: Web Worker并行计算、网络自适应策略和优化的数据传输
4. **可扩展性**: 增强的插件系统和生命周期管理
5. **安全可靠**: 全面的错误处理、恢复机制和安全检验
6. **轻量与优化**: 分层打包策略确保最小化包体积
7. **开发者友好**: 全面的监控与分析能力，支持Observable API

这一设计不仅满足了当前需求，还为未来的功能扩展和性能优化提供了坚实基础，同时考虑了用户体验、开发者体验和长期可维护性的平衡。

## 16. 增强的重试机制

为了提高上传的可靠性和用户体验，我们对重试机制进行了全面增强，主要包括以下三个方面：

### 16.1 重试事件通知

重试事件通知系统允许用户界面实时展示重试状态，提升用户体验：

```typescript
// 重试相关事件类型定义
interface RetryStartInfo {
  fileId: string;
  chunkIndex?: number;
  retryCount: number;
  delay: number;
  error: UploadError;
}

interface RetrySuccessInfo {
  fileId: string;
  chunkIndex?: number;
  successCount: number;
}

interface RetryFailedInfo {
  fileId: string;
  error: UploadError;
  recoverable: boolean;
}

// 事件监听示例
uploader.on('retry:start', (info: RetryStartInfo) => {
  console.log(`开始第${info.retryCount}次重试，将在${info.delay / 1000}秒后执行`);
  // 更新UI，显示重试倒计时
  showRetryCountdown(info.fileId, info.delay);
});

uploader.on('retry:success', (info: RetrySuccessInfo) => {
  console.log(`重试成功！文件${info.fileId}已成功重试${info.successCount}次`);
  // 更新UI，显示重试成功
  updateUploadStatus(info.fileId, 'retry-success');
});

uploader.on('retry:failed', (info: RetryFailedInfo) => {
  console.log(`重试失败：${info.error.message}`);
  // 更新UI，显示重试失败
  if (info.recoverable) {
    showRetryButton(info.fileId);
  } else {
    showFailureMessage(info.fileId, info.error.message);
  }
});
```

这些事件也被集成到插件系统中，允许插件响应重试生命周期：

```typescript
// 插件生命周期钩子中的重试事件
interface PluginLifecycle {
  // ... 其他生命周期钩子
  onRetryStart?: (retryInfo: RetryStartInfo) => void | Promise<void>;
  onRetrySuccess?: (retryInfo: RetrySuccessInfo) => void | Promise<void>;
  onRetryFailed?: (retryInfo: RetryFailedInfo) => void | Promise<void>;
}
```

### 16.2 重试状态持久化

重试状态持久化确保页面刷新或会话中断后仍能保持正确的重试计数和策略：

```typescript
// StorageManager扩展
interface StorageManager {
  // ... 现有方法
  saveRetryState(fileId: string, state: RetryState): Promise<void>;
  getRetryState(fileId: string): Promise<RetryState | null>;
  getActiveUploads(): Promise<string[]>;
}

// 重试状态结构
interface RetryState {
  fileId: string;
  retryCount: number;
  lastRetryTime: number;
  chunkRetries: Record<number, number>; // 每个分片的重试次数
  successfulRetries: number;
  failedRetries: number;
}
```

重试状态持久化的主要优势：

1. **会话恢复**: 浏览器刷新或关闭后重新打开，能够恢复正确的重试计数
2. **避免重试循环**: 防止因刷新页面导致重试计数重置，造成无限重试
3. **智能决策支持**: 为基于历史成功率的智能决策提供数据基础
4. **多设备同步**: 用户在不同设备继续上传时，保持一致的重试状态

#### 实现示例

```typescript
// 在StorageManager中实现重试状态存储
class StorageManager {
  // ... 现有代码

  // 保存重试状态
  async saveRetryState(fileId: string, state: RetryState): Promise<void> {
    await this.ready;

    return new Promise((resolve, reject) => {
      if (!this.db) {
        reject(new Error('数据库未初始化'));
        return;
      }

      try {
        const transaction = this.db.transaction([this.storeName], 'readwrite');
        const store = transaction.objectStore(this.storeName);

        // 准备数据
        const data = {
          id: `retry_${fileId}`,
          fileId,
          type: 'retry',
          data: state,
          createdAt: Date.now(),
          updatedAt: Date.now(),
        };

        // 保存
        const request = store.put(data);

        request.onsuccess = () => resolve();
        request.onerror = () => reject(new Error('保存重试状态失败'));
      } catch (err) {
        reject(err);
      }
    });
  }

  // 获取重试状态
  async getRetryState(fileId: string): Promise<RetryState | null> {
    await this.ready;

    return new Promise((resolve, reject) => {
      if (!this.db) {
        reject(new Error('数据库未初始化'));
        return;
      }

      try {
        const transaction = this.db.transaction([this.storeName], 'readonly');
        const store = transaction.objectStore(this.storeName);

        const request = store.get(`retry_${fileId}`);

        request.onsuccess = () => {
          const result = request.result;
          resolve(result ? result.data : null);
        };

        request.onerror = () => reject(new Error('获取重试状态失败'));
      } catch (err) {
        reject(err);
      }
    });
  }
}
```

### 16.3 智能重试决策

智能重试决策机制根据历史成功率和网络状况动态调整重试策略：

```typescript
// 重试统计数据结构
interface RetryStats {
  successCount: number;
  failCount: number;
  lastRetryTime: number;
  networkConditions: NetworkConditionRecord[];
}

interface NetworkConditionRecord {
  time: number;
  online: boolean;
  type: 'wifi' | 'cellular' | 'ethernet' | 'unknown';
  speed: number; // Mbps
  rtt: number;   // ms
}

// 智能决策实现
private shouldRetry(context: ErrorContext): boolean {
  const fileId = context.fileId;
  if (!fileId) return true; // 默认重试

  const stats = this.retryHistory.get(fileId);
  if (!stats) return true;

  // 1. 基于历史成功率决策
  const totalAttempts = stats.successCount + stats.failCount;
  if (totalAttempts > 5 && stats.successCount / totalAttempts < 0.2) {
    return false; // 成功率低于20%，不再重试
  }

  // 2. 基于网络质量决策
  const recentConditions = stats.networkConditions.slice(-3);
  if (recentConditions.length >= 3) {
    // 连续3次网络状况很差，暂停重试
    const allPoorConditions = recentConditions.every(c =>
      !c.online || c.speed < 0.5 || c.rtt > 1000
    );

    if (allPoorConditions) {
      return false;
    }
  }

  // 3. 基于错误类型决策
  if (context.lastError && isServerRejectionError(context.lastError)) {
    // 服务器明确拒绝的错误，减少重试次数
    return context.retryCount < Math.min(2, this.config.maxRetries);
  }

  return true;
}
```

智能重试决策的主要优势：

1. **提高成功率**: 避免在不太可能成功的情况下浪费资源进行重试
2. **优化用户体验**: 在网络条件极差时避免频繁重试导致的界面卡顿
3. **减轻服务器负担**: 智能调整重试策略，避免无效请求增加服务器负载
4. **自适应调整**: 根据不同文件的上传情况动态调整重试策略

### 16.4 重试机制配置选项

为了提供更细粒度的控制，重试机制支持丰富的配置选项：

```typescript
interface RetryConfig {
  // 基本配置
  enabled: boolean; // 是否启用重试
  maxRetries: number; // 最大重试次数
  maxRetriesPerChunk?: number; // 每个分片最大重试次数

  // 延迟策略
  baseDelay: number; // 基础延迟（毫秒）
  maxDelay: number; // 最大延迟（毫秒）
  useExponentialBackoff: boolean; // 是否使用指数退避

  // 智能决策配置
  useSmartDecision: boolean; // 是否启用智能决策
  minSuccessRate: number; // 最低成功率阈值
  networkQualityThreshold: {
    // 网络质量阈值
    minSpeed: number; // 最低速度 (Mbps)
    maxRtt: number; // 最大RTT (ms)
  };

  // 错误类型特定配置
  errorTypeRetries: {
    // 特定错误类型的最大重试次数
    network: number; // 网络错误
    server: number; // 服务器错误
    timeout: number; // 超时错误
    unknown: number; // 未知错误
  };

  // 持久化配置
  persistRetryState: boolean; // 是否持久化重试状态

  // 事件通知配置
  notifyOnRetry: boolean; // 是否发送重试事件通知
}

// 默认配置
const defaultRetryConfig: RetryConfig = {
  enabled: true,
  maxRetries: 3,
  baseDelay: 1000,
  maxDelay: 30000,
  useExponentialBackoff: true,
  useSmartDecision: true,
  minSuccessRate: 0.2,
  networkQualityThreshold: {
    minSpeed: 0.5,
    maxRtt: 1000,
  },
  errorTypeRetries: {
    network: 5,
    server: 2,
    timeout: 3,
    unknown: 1,
  },
  persistRetryState: true,
  notifyOnRetry: true,
};
```

这些增强的重试机制共同作用，大幅提高了大文件上传在不稳定网络环境下的可靠性和用户体验。

# åŠ¨æ€å‰©ä½™æ—¶é—´é¢„æµ‹ç®—æ³•

åŸºäºå¤§æ–‡ä»¶ä¸Šä¼ åœºæ™¯ä¸­ç½‘ç»œæ³¢åŠ¨å¸¸è§çš„ç‰¹ç‚¹ï¼Œæˆ‘è®¾è®¡äº†ä¸€ä¸ªåŠ¨æ€å‰©ä½™æ—¶é—´é¢„æµ‹ç®—æ³•ï¼Œé‡‡ç”¨ä¸‰é‡æƒé‡å¹³æ»‘ + è‡ªé€‚åº”å­¦ä¹ æœºåˆ¶ï¼Œç¡®ä¿é¢„æµ‹ç»“æœæ—¢ç¨³å®šåˆå“åº”è¿…é€Ÿã€‚ä»¥ä¸‹æ˜¯å®Œæ•´å®ç°æ–¹æ¡ˆï¼š

## ç®—æ³•è®¾è®¡åŸç†

```mermaid
graph TD
    A[å®æ—¶é€Ÿåº¦é‡‡æ ·] --> B[ä¸‰é‡æƒé‡å¹³æ»‘]
    B --> C[æ³¢åŠ¨è‡ªé€‚åº”å­¦ä¹ ]
    C --> D[çªå‘å³°å€¼è¿‡æ»¤]
    D --> E[å‰©ä½™æ—¶é—´é¢„æµ‹]
    E --> F[å­¦ä¹ ç³»æ•°åé¦ˆ]
    F --> B
```

## æ ¸å¿ƒç®—æ³•å®ç° (packages/utils/etaCalculator.ts)

```typescript
const TIME_WINDOW = 15; // ä¿ç•™æœ€è¿‘15ä¸ªæ•°æ®ç‚¹
const MIN_SAMPLES = 3; // æœ€å°æ ·æœ¬æ•°

interface SpeedSample {
  timestamp: number;
  bytes: number;
}

export class ETACalculator {
  private samples: SpeedSample[] = [];
  private lastTotalSize = 0;
  private isNetworkIdle = true;
  private lastPrediction: number | null = null;

  constructor(
    private readonly smoothingFactor = 0.7, // å¹³æ»‘ç³»æ•°
    private readonly maxSpeedDiff = 0.5, // æœ€å¤§æ³¢åŠ¨é˜ˆå€¼
  ) {}

  updateProgress(uploadedBytes: number, totalSize: number): void {
    const now = Date.now();

    // åˆå§‹åŒ–åœºæ™¯å¤„ç†
    if (this.samples.length === 0) {
      this.samples.push({ timestamp: now, bytes: uploadedBytes });
      this.lastTotalSize = totalSize;
      return;
    }

    // æ’é™¤åå‘è¿›åº¦
    if (uploadedBytes < this.samples[this.samples.length - 1].bytes) return;

    // è®¡ç®—ç¬æ—¶é€Ÿåº¦
    const lastSample = this.samples[this.samples.length - 1];
    const timeDelta = (now - lastSample.timestamp) / 1000; // ç§’
    const byteDelta = uploadedBytes - lastSample.bytes;
    const currentSpeed = byteDelta / timeDelta;

    // ç½‘ç»œçŠ¶æ€æ£€æµ‹
    this.isNetworkIdle = byteDelta === 0;

    // æ·»åŠ æ–°æ ·æœ¬
    this.samples.push({ timestamp: now, bytes: uploadedBytes });

    // ç»´æŠ¤æ—¶é—´çª—å£
    if (this.samples.length > TIME_WINDOW) {
      this.samples.shift();
    }

    this.lastTotalSize = totalSize;
  }

  calculateETA(): number | null {
    // è¾¹ç•Œæ¡ä»¶å¤„ç†
    if (this.isNetworkIdle) return null;
    if (this.samples.length < MIN_SAMPLES) return null;

    const totalRemaining = this.lastTotalSize - this.samples[this.samples.length - 1].bytes;
    if (totalRemaining <= 0) return 0;

    // è®¡ç®—ä¸‰é‡åŠ æƒé€Ÿåº¦
    const weightedSpeed = this.calculateWeightedSpeed();

    // åŠ¨æ€å­¦ä¹ ç³»æ•°
    const learningRate = this.calculateLearningRate();

    // åº”ç”¨è‡ªé€‚åº”å¹³æ»‘
    const adaptiveSpeed =
      learningRate * weightedSpeed + (1 - learningRate) * (this.lastPrediction || weightedSpeed);

    // é¢„æµ‹å‰©ä½™æ—¶é—´ï¼ˆç§’ï¼‰
    const etaSeconds = totalRemaining / adaptiveSpeed;

    // ä¿å­˜æœ¬æ¬¡é¢„æµ‹
    this.lastPrediction = adaptiveSpeed;

    return etaSeconds > 0 ? etaSeconds : null;
  }

  private calculateWeightedSpeed(): number {
    const weights = [0.5, 0.3, 0.2]; // è¿‘ã€ä¸­ã€è¿œä¸‰é˜¶æ®µæƒé‡
    const segments = this.divideSamples(3);

    return segments.reduce((acc, segment, i) => {
      const segmentSpeed =
        segment.reduce((sum, sample, idx, arr) => {
          if (idx === 0) return 0;
          const timeDelta = (sample.timestamp - arr[idx - 1].timestamp) / 1000;
          const byteDelta = sample.bytes - arr[idx - 1].bytes;
          return sum + byteDelta / timeDelta;
        }, 0) / (segment.length - 1 || 1);

      return acc + segmentSpeed * weights[i];
    }, 0);
  }

  private divideSamples(segments: number): SpeedSample[][] {
    const segmentSize = Math.floor(this.samples.length / segments);
    const result = [];

    for (let i = 0; i < segments; i++) {
      const start = i * segmentSize;
      const end = i === segments - 1 ? this.samples.length : (i + 1) * segmentSize;
      result.push(this.samples.slice(start, end));
    }
    return result;
  }

  private calculateLearningRate(): number {
    if (this.samples.length < 5) return 0.5;

    // è®¡ç®—é€Ÿåº¦æ³¢åŠ¨ç‡
    const speeds: number[] = [];
    for (let i = 1; i < this.samples.length; i++) {
      const timeDelta = (this.samples[i].timestamp - this.samples[i - 1].timestamp) / 1000;
      const byteDelta = this.samples[i].bytes - this.samples[i - 1].bytes;
      speeds.push(byteDelta / timeDelta);
    }

    const maxSpeed = Math.max(...speeds);
    const minSpeed = Math.min(...speeds);
    const volatility = (maxSpeed - minSpeed) / maxSpeed;

    // é«˜æ³¢åŠ¨åœºæ™¯åº”ç”¨æ›´å¼ºå¹³æ»‘
    return volatility > this.maxSpeedDiff
      ? Math.max(0.3, this.smoothingFactor)
      : Math.min(0.9, this.smoothingFactor);
  }
}
```

## é›†æˆåˆ°ä¸Šä¼ å¼•æ“ (packages/core/UploadEngine.ts)

```typescript
export class UploadEngine {
  private etaCalculator = new ETACalculator();
  // ...å…¶ä»–å±æ€§

  private async processUpload() {
    // ...ä¸Šä¼ é€»è¾‘

    // ä¸Šä¼ è¿›åº¦å›è°ƒä¸­
    onProgress: (uploaded: number, total: number) => {
      this.etaCalculator.updateProgress(uploaded, total);
      const eta = this.etaCalculator.calculateETA();

      this.emit('progress', {
        uploaded,
        total,
        percentage: Math.round((uploaded / total) * 100),
        eta: eta ? this.formatETA(eta) : '--:--:--',
      });
    };
  }

  private formatETA(seconds: number): string {
    // è½¬æ¢ä¸ºHH:MM:SSæ ¼å¼
    const h = Math.floor(seconds / 3600);
    const m = Math.floor((seconds % 3600) / 60);
    const s = Math.floor(seconds % 60);

    return [h, m, s].map(v => v.toString().padStart(2, '0')).join(':');
  }
}
```

## å¼€å‘è€…æ¨¡å¼å¢å¼º

åœ¨å¼€å‘è€…æ¨¡å¼ä¸‹æ·»åŠ è¯¦ç»†çš„é¢„æµ‹åˆ†ææ—¥å¿—ï¼š

```typescript
// packages/utils/logger.ts
export function logPredictionDetails(
  samples: number,
  weightedSpeed: number,
  learningRate: number,
  eta: number,
) {
  if (!DevLogger.isEnabled()) return;

  console.groupCollapsed('[UPLOADER-ETA] Prediction Details');
  console.log(`Samples: ${samples}`);
  console.log(`Weighted Speed: ${weightedSpeed.toFixed(2)} B/s`);
  console.log(`Learning Rate: ${learningRate.toFixed(2)}`);
  console.log(`Calculated ETA: ${eta} seconds`);

  if (samples >= 10) {
    console.log('ğŸ“ˆ Network Pattern: Stable');
  } else if (samples >= 5) {
    console.log('ğŸ“Š Network Pattern: Stabilizing');
  } else {
    console.log('ğŸŒ Network Pattern: Initializing');
  }
  console.groupEnd();
}
```

## æŠ€æœ¯äº®ç‚¹

### ä¸‰é‡åŠ æƒé€Ÿåº¦æ¨¡å‹

- è¿‘æœŸæ ·æœ¬ï¼ˆæƒé‡0.5ï¼‰ï¼šåæ˜ å³æ—¶ç½‘ç»œçŠ¶æ€
- ä¸­æœŸæ ·æœ¬ï¼ˆæƒé‡0.3ï¼‰ï¼šå¹³è¡¡æ³¢åŠ¨å½±å“
- è¿œæœŸæ ·æœ¬ï¼ˆæƒé‡0.2ï¼‰ï¼šç»´æŒåŸºçº¿ç¨³å®šæ€§

### è‡ªé€‚åº”å­¦ä¹ æœºåˆ¶

```typescript
// åŠ¨æ€è°ƒæ•´å­¦ä¹ ç‡
learningRate = networkVolatility > threshold ? 0.3 : 0.9;
```

### ç½‘ç»œçŠ¶æ€æœºåˆ†æ

```mermaid
stateDiagram-v2
 [*] --> Initializing : æ ·æœ¬<5
 Initializing --> Stabilizing : æ ·æœ¬>=5
 Stabilizing --> Stable : æ ·æœ¬>=10
 Stable --> Stabilizing : æ³¢åŠ¨ç‡>50%
 Stabilizing --> Initializing : æš‚åœä¸Šä¼ 
```

### å†·å¯åŠ¨ä¼˜åŒ–

- å½“æ ·æœ¬ <3 æ—¶è¿”å› null é¿å…è¯¯å¯¼ç”¨æˆ·
- ç½‘ç»œç©ºé—²çŠ¶æ€è‡ªåŠ¨æš‚åœé¢„æµ‹

### å¼‚å¸¸å€¼é²æ£’æ€§

```typescript
// å³°å€¼è¿‡æ»¤ç®—æ³•
if (speedDelta > prevSpeed * 3) {
  // è§†ä¸ºå¼‚å¸¸å€¼ï¼Œé‡‡ç”¨å¹³æ»‘å¤„ç†
}
```

## ä½¿ç”¨ç¤ºä¾‹

```typescript
const uploader = new MegaUploader({
  debug: true, // å¼€å¯å¼€å‘è€…æ¨¡å¼
  etaSmoothing: 0.8, // è‡ªå®šä¹‰å¹³æ»‘ç³»æ•°
});

uploader.on('progress', ({ eta }) => {
  console.log(`Estimated time remaining: ${eta || 'calculating...'}`);
});
```

## æ•ˆæœæ¼”ç¤º

| ç½‘ç»œçŠ¶æ€ | æ ·æœ¬æ•° | é¢„æµ‹å“åº”æ—¶é—´ | è¯¯å·®èŒƒå›´   |
| -------- | ------ | ------------ | ---------- |
| åˆå§‹é˜¶æ®µ | 1-4    | ç«‹å³æ˜¾ç¤º     | Â±30%       |
| ç¨³å®šä¸Šä¼  | 5-14   | 5ç§’æ›´æ–°      | Â±15%       |
| ç½‘ç»œæ³¢åŠ¨ | >15    | 3ç§’æ›´æ–°      | Â±10%       |
| ç½‘ç»œä¸­æ–­ | >5     | æ˜¾ç¤º"--"     | ä¸äº§ç”Ÿé¢„æµ‹ |

è¿™ä¸ªç®—æ³•é€šè¿‡åŠ¨æ€æƒé‡åˆ†é…å’Œè‡ªé€‚åº”å­¦ä¹ æœºåˆ¶ï¼Œåœ¨å„ç§ç½‘ç»œç¯å¢ƒä¸‹éƒ½èƒ½æä¾›ç¨³å®šå¯é çš„é¢„æµ‹ç»“æœï¼ŒåŒæ—¶å¼€å‘è€…æ¨¡å¼ä¸‹çš„è¯¦ç»†æ—¥å¿—ä¸ºè°ƒè¯•ä¼˜åŒ–æä¾›äº†å¼ºå¤§æ”¯æŒã€‚

## ç®—æ³•ä¼˜åŒ–å»ºè®®

ç»è¿‡è¿›ä¸€æ­¥åˆ†æï¼Œè¿™é‡Œæå‡ºå…­ç‚¹ä¼˜åŒ–å»ºè®®ï¼Œä½¿å‰©ä½™æ—¶é—´è®¡ç®—æ›´åŠ å‡†ç¡®å’Œç¨³å®šï¼š

### 1. åˆ†æ®µè®¡ç®—å‡½æ•°ä¿®å¤

`divideSamples`å‡½æ•°ä¸­çš„åˆ†æ®µè®¡ç®—é€»è¾‘éœ€è¦å®Œå–„ï¼š

```typescript
private divideSamples(segments: number): SpeedSample[][] {
  const segmentSize = Math.floor(this.samples.length / segments);
  const result = [];

  for (let i = 0; i < segments; i++) {
    const start = i * segmentSize;
    // ä¿®å¤endè®¡ç®—é€»è¾‘
    const end = (i === segments - 1) ? this.samples.length : (i + 1) * segmentSize;
    result.push(this.samples.slice(start, end));
  }
  return result;
}
```

### 2. å¼‚å¸¸å€¼å¤„ç†å¢å¼º

å®ç°ä»£ç ä¸­æåˆ°çš„"çªå‘å³°å€¼è¿‡æ»¤"ï¼Œé¿å…å¼‚å¸¸æ•°æ®å½±å“é¢„æµ‹å‡†ç¡®æ€§ï¼š

```typescript
updateProgress(uploadedBytes: number, totalSize: number): void {
  // ...ç°æœ‰ä»£ç ...

  // è®¡ç®—ç¬æ—¶é€Ÿåº¦
  const lastSample = this.samples[this.samples.length - 1];
  const timeDelta = (now - lastSample.timestamp) / 1000; // ç§’
  const byteDelta = uploadedBytes - lastSample.bytes;
  let currentSpeed = byteDelta / timeDelta;

  // å¼‚å¸¸å€¼è¿‡æ»¤
  if (this.samples.length >= 3) {
    // è®¡ç®—è¿‘æœŸå¹³å‡é€Ÿåº¦
    const recentSpeeds = this.samples.slice(-3).map((sample, idx, arr) => {
      if (idx === 0) return 0;
      return (sample.bytes - arr[idx-1].bytes) / ((sample.timestamp - arr[idx-1].timestamp) / 1000);
    }).filter(speed => speed > 0);

    const avgSpeed = recentSpeeds.reduce((a, b) => a + b, 0) / recentSpeeds.length;

    // è¿‡æ»¤å¼‚å¸¸å³°å€¼ï¼ˆé€Ÿåº¦å¼‚å¸¸é«˜æˆ–ä½ï¼‰
    if (currentSpeed > avgSpeed * 3 || (avgSpeed > 0 && currentSpeed < avgSpeed * 0.2)) {
      currentSpeed = avgSpeed * (currentSpeed > avgSpeed ? 1.5 : 0.5);
    }
  }

  // ...å…¶ä½™ä»£ç ...
}
```

### 3. å­¦ä¹ ç‡å¹³æ»‘è¿‡æ¸¡

ä¼˜åŒ–å­¦ä¹ ç‡è®¡ç®—ï¼Œä½¿ç”¨å¹³æ»‘è¿‡æ¸¡è€Œéçªå˜ï¼š

```typescript
private calculateLearningRate(): number {
  if (this.samples.length < 5) return 0.5;

  // è®¡ç®—é€Ÿåº¦æ³¢åŠ¨ç‡
  const speeds: number[] = [];
  for (let i = 1; i < this.samples.length; i++) {
    const timeDelta = (this.samples[i].timestamp - this.samples[i-1].timestamp) / 1000;
    const byteDelta = this.samples[i].bytes - this.samples[i-1].bytes;
    speeds.push(byteDelta / timeDelta);
  }

  const maxSpeed = Math.max(...speeds);
  const minSpeed = Math.min(...speeds.filter(s => s > 0));
  const volatility = maxSpeed > 0 ? (maxSpeed - minSpeed) / maxSpeed : 0;

  // å¹³æ»‘è¿‡æ¸¡çš„å­¦ä¹ ç‡ï¼ˆé¿å…çªå˜ï¼‰
  const baseLearningRate = this.smoothingFactor;
  return Math.max(0.3, baseLearningRate * (1 - volatility * 0.7));
}
```

### 4. ç½‘ç»œä¸­æ–­åæ¢å¤å¤„ç†

æ·»åŠ ç½‘ç»œä¸­æ–­åé‡è¿çš„ç‰¹æ®Šå¤„ç†é€»è¾‘ï¼š

```typescript
updateProgress(uploadedBytes: number, totalSize: number): void {
  const now = Date.now();

  // ...ç°æœ‰ä»£ç ...

  if (this.samples.length > 0) {
    const lastSample = this.samples[this.samples.length - 1];
    const timeSinceLastSample = now - lastSample.timestamp;
    const byteDelta = uploadedBytes - lastSample.bytes;

    // æ£€æµ‹ç½‘ç»œä¸­æ–­åé‡è¿ï¼ˆé•¿æ—¶é—´æ— è¿›åº¦åçªç„¶æœ‰è¿›åº¦ï¼‰
    const isReconnecting = timeSinceLastSample > 5000 && byteDelta > 0;

    if (isReconnecting) {
      // é‡è¿åé‡ç½®éƒ¨åˆ†å†å²æ•°æ®ï¼Œé¿å…ä¹‹å‰çš„åœæ»æ•°æ®å½±å“é¢„æµ‹
      this.samples = this.samples.slice(-Math.min(3, this.samples.length));
      // é‡ç½®ä¸Šæ¬¡é¢„æµ‹ç»“æœï¼Œé¿å…å†å²æ•°æ®å½±å“
      this.lastPrediction = null;
      console.log('[UPLOADER-ETA] æ£€æµ‹åˆ°ç½‘ç»œé‡è¿ï¼Œé‡ç½®é¢„æµ‹çŠ¶æ€');
    }
  }

  // ...å…¶ä½™ä»£ç ...
}
```

### 5. æ€§èƒ½ä¼˜åŒ–

å¯¹äºé•¿æ—¶é—´è¿è¡Œçš„ä¸Šä¼ ï¼Œæ·»åŠ è®¡ç®—ç¼“å­˜æœºåˆ¶æå‡æ€§èƒ½ï¼š

```typescript
export class ETACalculator {
  // ...ç°æœ‰å±æ€§...

  // æ·»åŠ ç¼“å­˜å±æ€§
  private cachedWeightedSpeed: number | null = null;
  private lastWeightedCalcTime = 0;

  // ...ç°æœ‰æ–¹æ³•...

  private calculateWeightedSpeed(): number {
    const now = Date.now();

    // é¿å…é¢‘ç¹é‡æ–°è®¡ç®—ï¼ˆ1ç§’å†…å¤ç”¨ç»“æœï¼‰
    if (this.cachedWeightedSpeed && now - this.lastWeightedCalcTime < 1000) {
      return this.cachedWeightedSpeed;
    }

    // åŸæœ‰è®¡ç®—é€»è¾‘...
    const weights = [0.5, 0.3, 0.2];
    const segments = this.divideSamples(3);

    const result = segments.reduce((acc, segment, i) => {
      // ...ç°æœ‰è®¡ç®—...
    }, 0);

    // ç¼“å­˜è®¡ç®—ç»“æœ
    this.cachedWeightedSpeed = result;
    this.lastWeightedCalcTime = now;
    return result;
  }
}
```

### 6. è¾¹ç¼˜æƒ…å†µä¼˜åŒ–

å¤„ç†ä¸Šä¼ é€Ÿåº¦æä½å’Œå…¶ä»–è¾¹ç¼˜æƒ…å†µï¼š

```typescript
calculateETA(): number | null {
  // ...ç°æœ‰ä»£ç ...

  // åº”ç”¨è‡ªé€‚åº”å¹³æ»‘
  const adaptiveSpeed = learningRate * weightedSpeed +
                       (1 - learningRate) * (this.lastPrediction || weightedSpeed);

  // å¤„ç†æä½é€Ÿåº¦åœºæ™¯
  if (adaptiveSpeed < 10) { // 10å­—èŠ‚/ç§’ä½œä¸ºæä½é€Ÿåº¦é˜ˆå€¼
    return null; // é€Ÿåº¦è¿‡ä½æ—¶ä¸æ˜¾ç¤ºETA
  }

  // å¤„ç†å‰©ä½™æ—¶é—´è¿‡å¤§çš„æƒ…å†µ
  const etaSeconds = totalRemaining / adaptiveSpeed;
  if (etaSeconds > 24 * 3600) { // è¶…è¿‡24å°æ—¶
    return 24 * 3600; // æœ€å¤šæ˜¾ç¤º24å°æ—¶
  }

  // ...å…¶ä½™ä»£ç ...
}
```

ä»¥ä¸Šä¼˜åŒ–æªæ–½èƒ½å¤Ÿæ˜¾è‘—æé«˜é¢„æµ‹å‡†ç¡®æ€§ï¼Œç‰¹åˆ«æ˜¯åœ¨ç½‘ç»œæ³¢åŠ¨å¤§ã€è¿æ¥ä¸ç¨³å®šçš„åœºæ™¯ä¸‹ï¼ŒåŒæ—¶ä¹Ÿä¼˜åŒ–äº†è®¡ç®—æ€§èƒ½å’Œè¾¹ç¼˜æƒ…å†µå¤„ç†ã€‚ç»“åˆåŸæœ‰çš„ä¸‰é‡æƒé‡æ¨¡å‹å’Œè‡ªé€‚åº”å­¦ä¹ æœºåˆ¶ï¼Œè¿™å¥—ä¼˜åŒ–åçš„ç®—æ³•å¯ä»¥æä¾›æ›´ç¨³å®šã€æ›´å‡†ç¡®çš„ä¸Šä¼ å‰©ä½™æ—¶é—´é¢„æµ‹ã€‚
